<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OBPI - Operational in Browser Persisted Instance v0.6 (PEPx)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>

    <style>
        :root {
            --bg-color: #1a1a2e; 
            --window-bg: rgba(245, 245, 245, 0.97); 
            --window-border: #909090;
            --window-header-bg: #2c2f3b;
            --text-color-dark: #1f2937;
            --text-color-light: #e5e7eb;
            --accent-color: #6366f1; /* Indigo-500 */
            --accent-color-darker: #4f46e5; /* Indigo-600 */
            --taskbar-bg: rgba(25, 28, 38, 0.98);
            --font-main: 'Inter', sans-serif;
            --font-mono: 'Roboto Mono', monospace;
            /* PEPx Specific Colors from its original CSS */
            --pepx-primary-color: #3498db;
            --pepx-secondary-color: #2980b9;
            --pepx-bg-color: #f5f5f5;
            --pepx-light-bg: #ffffff;
            --pepx-text-color: #333;
            --pepx-border-color: #ddd;
        }
        body.light-theme {
            --bg-color: #e0e0e0;
            --window-bg: rgba(255, 255, 255, 0.98);
            --window-border: #c0c0c0;
            --window-header-bg: #52525b; 
            --text-color-dark: #18181b; 
            --text-color-light: #f8fafc; 
            --taskbar-bg: rgba(200, 200, 210, 0.98);
            /* PEPx light theme adjustments */
            --pepx-primary-color: #3498db;
            --pepx-secondary-color: #2980b9;
            --pepx-bg-color: #f0f0f0;
            --pepx-light-bg: #ffffff;
            --pepx-text-color: #333;
            --pepx-border-color: #ccc;
        }
        body.light-theme #desktop { background-color: var(--bg-color); }
        body.light-theme .taskbar { background-color: var(--taskbar-bg); border-top: 1px solid #a0a0b0; }
        body.light-theme .taskbar-button { background-color: rgba(0,0,0,0.1); color: var(--text-color-dark); }
        body.light-theme .taskbar-button:hover { background-color: rgba(0,0,0,0.2); }
        body.light-theme .os-window { background-color: var(--window-bg); border-color: var(--window-border); color: var(--text-color-dark); }
        body.light-theme .window-header { background-color: var(--window-header-bg); color: var(--text-color-light); }
        body.light-theme .window-content { background-color: #ffffff; color: var(--text-color-dark); }
        body.light-theme #window-terminal .window-content { background-color: #f0f0f0; color: #121212; }
        body.light-theme #terminal-prompt { color: #2563eb; } 
        body.light-theme #terminal-input { color: #121212; caret-color: #121212; }
        body.light-theme #pyscript-output-area, body.light-theme #pyide-output-area { background-color: #f9f9f9; color: #333; border-color: #ddd; }
        body.light-theme #pyscript-code-area, body.light-theme #pyide-code-area { background-color: #fff; color: #333; border-color: #ccc; }
        body.light-theme #window-ai-assistant .window-content { background-color: #e5e7eb; color: #1f2937; }
        body.light-theme .ai-message.user { background-color: var(--accent-color); }
        body.light-theme .ai-message.assistant { background-color: #d1d5db; } 
        body.light-theme .desktop-icon span { color: var(--text-color-dark); text-shadow: 1px 1px 1px #fff; }
        /* PEPx light theme specific window content */
        body.light-theme #window-pepx-explorer .window-content { background-color: var(--pepx-bg-color); color: var(--pepx-text-color); }
        body.light-theme #window-pepx-explorer .pepx-toolbar { background-color: #e8e8e8; border-bottom-color: var(--pepx-border-color); }
        body.light-theme #window-pepx-explorer .pepx-toolbar button { background-color: var(--pepx-primary-color); }
        body.light-theme #window-pepx-explorer .pepx-toolbar button:hover { background-color: var(--pepx-secondary-color); }
        body.light-theme #window-pepx-explorer .pepx-file-list { /* No specific change, inherits window content bg */ }
        body.light-theme #window-pepx-explorer .pepx-item:hover { background-color: rgba(0,0,0,0.03); }
        body.light-theme #window-pepx-explorer .pepx-status-bar { background-color: #e8e8e8; border-top-color: var(--pepx-border-color); color: #444; }


        body { font-family: var(--font-main); overflow: hidden; background-color: var(--bg-color); color: var(--text-color-light); }
        .cli-font { font-family: var(--font-mono); }
        .os-window { min-width: 320px; min-height: 220px; background-color: var(--window-bg); border: 1px solid var(--window-border); box-shadow: 0 6px 20px rgba(0,0,0,0.3); position: absolute; display: flex; flex-direction: column; border-radius: 10px; overflow: hidden; resize: both; }
        .os-window.active-window { border-color: var(--accent-color); box-shadow: 0 8px 25px rgba(0,0,0,0.35); }
        .window-header { background-color: var(--window-header-bg); color: var(--text-color-light); padding: 10px 15px; cursor: move; display: flex; justify-content: space-between; align-items: center; border-top-left-radius: 9px; border-top-right-radius: 9px; user-select: none; }
        .window-title { font-weight: 600; font-size: 0.95rem; }
        .window-controls button { background: none; border: none; color: var(--text-color-light); font-size: 1.2rem; padding: 2px 5px; margin-left: 7px; cursor: pointer; border-radius: 4px; line-height: 1; }
        .window-controls button:hover { background-color: rgba(255,255,255,0.15); }
        .window-content { flex-grow: 1; padding: 0; /* Remove padding for apps that manage their own */ overflow: auto; background-color: var(--window-bg); color: var(--text-color-dark); }
        .window-content iframe { width: 100%; height: 100%; border: none; }
        #desktop { width: 100vw; height: 100vh; position: relative; overflow: hidden; padding: 10px; display: flex; flex-direction: column; flex-wrap: wrap; align-content: flex-start; gap:10px; }
        .desktop-icon { display: flex; flex-direction: column; align-items: center; width: 80px; padding: 5px; border-radius: 5px; cursor: pointer; text-align: center; user-select:none; }
        .desktop-icon:hover { background-color: rgba(255,255,255,0.1); }
        .desktop-icon img, .desktop-icon .icon-placeholder { width: 48px; height: 48px; margin-bottom: 5px; object-fit: contain; }
        .desktop-icon .icon-placeholder { font-size: 32px; display:flex; align-items:center; justify-content:center; background-color: rgba(255,255,255,0.05); border-radius:4px; }
        .desktop-icon span { font-size: 0.75rem; color: var(--text-color-light); word-break: break-word; line-height: 1.2; max-height: 2.4em; overflow:hidden; }

        #webgl-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -10; } 
        .taskbar { position: fixed; bottom: 0; left: 0; width: 100%; height: 50px; background-color: var(--taskbar-bg); display: flex; align-items: center; padding: 0 12px; z-index: 10000; border-top: 1px solid rgba(255,255,255,0.1); }
        .taskbar-button { background-color: rgba(255,255,255,0.1); color: var(--text-color-light); padding: 7px 14px; margin-right: 8px; border-radius: 5px; cursor: pointer; transition: background-color 0.2s; font-size: 0.85rem; border: 1px solid transparent; }
        .taskbar-button:hover { background-color: rgba(255,255,255,0.2); border-color: rgba(255,255,255,0.3); }
        #start-menu { position: fixed; bottom: 50px; left: 0; background-color: var(--taskbar-bg); border: 1px solid rgba(255,255,255,0.2); border-bottom:none; border-top-right-radius: 8px; padding: 10px; z-index: 9999; min-width: 250px; box-shadow: 0 -5px 15px rgba(0,0,0,0.2); }
        .start-menu-item { display: block; padding: 8px 12px; color: var(--text-color-light); text-decoration: none; border-radius: 4px; font-size:0.9rem; }
        .start-menu-item:hover { background-color: var(--accent-color); }
        
        .context-menu { position: absolute; background-color: #fff; border: 1px solid #ccc; box-shadow: 0 4px 15px rgba(0,0,0,0.2); border-radius: 6px; padding: 8px 0; z-index: 20000; min-width: 180px; }
        .context-menu-item { padding: 10px 20px; cursor: pointer; font-size: 0.9rem; color: #333; }
        .context-menu-item:hover { background-color: #f0f0f0; }
        /* Terminal Specific - padding handled by #window-terminal .window-content */
        #window-terminal .window-content { background-color: #121212; color: #e0e0e0; padding: 12px; display: flex; flex-direction: column-reverse; }
        #terminal-output { white-space: pre-wrap; word-break: break-all; flex-grow: 1; }
        #terminal-input-line { display: flex; align-items: center; padding-top: 6px; }
        #terminal-prompt { color: #00aaff; margin-right: 8px; }
        #terminal-input { background-color: transparent; border: none; color: #f0f0f0; outline: none; flex-grow: 1; caret-color: #f0f0f0; }
        
        /* AI Assistant Specific - padding handled by #window-ai-assistant .window-content */
        #window-ai-assistant .window-content { display: flex; flex-direction: column; background-color: #252a34; color: #e0e0e0; padding:0; }
        #ai-chat-output { flex-grow: 1; overflow-y: auto; padding: 12px; border-bottom: 1px solid #3a3f4b; }
        .ai-message { margin-bottom: 12px; padding: 10px 14px; border-radius: 8px; max-width: 85%; word-wrap: break-word; line-height: 1.5; }
        .ai-message.user { background-color: var(--accent-color); color: white; margin-left: auto; text-align: left; }
        .ai-message.assistant { background-color: #3a3f4b; margin-right: auto; }
        #ai-input-area { display: flex; padding: 12px; border-top: 1px solid #3a3f4b;}
        #ai-input { flex-grow: 1; padding: 10px 12px; border-radius: 6px; border: 1px solid #4a4f5a; background-color: #3a3f4b; color: #e0e0e0; outline: none; }
        #ai-send-button { margin-left: 10px; padding: 10px 18px; background-color: var(--accent-color); color: white; border: none; border-radius: 6px; cursor: pointer; }
        #ai-send-button:hover { background-color: var(--accent-color-darker); }
        
        /* Disk Manager Specific - padding handled by #window-disk-manager .window-content */
        #window-disk-manager .window-content { padding: 15px; }
        .volume-item { background-color: #e9ecef; padding: 10px; border-radius: 5px; margin-bottom:10px; border: 1px solid #ced4da;}
        .volume-item strong { color: var(--accent-color); }
        
        /* Ncurses App Specific - padding handled by #window-ncurses-app .window-content */
        #window-ncurses-app .window-content { background-color: #000033; color: #c0c0c0; font-family: 'Courier New', Courier, monospace; padding: 5px; overflow: hidden; }
        .ncurses-char { display: inline-block; width: 0.6em; text-align: center; }
        
        /* PyScript Runner & PyIDE Specific - padding handled by window content */
        #window-pyscript-runner .window-content, #window-py-ide .window-content { display: flex; flex-direction: column; gap: 10px; padding:10px; }
        #pyscript-code-area, #pyide-code-area { font-family: var(--font-mono); flex-grow: 1; border: 1px solid #ccc; padding: 8px; border-radius: 4px; background-color: #fdfdfd; color: #333; }
        #pyscript-output-area, #pyide-output-area { height: 150px; background-color: #1e1e1e; color: #e0e0e0; border: 1px solid #333; padding: 8px; border-radius: 4px; overflow-y: auto; white-space: pre-wrap; font-family: var(--font-mono); }
        
        .fullscreen-lock-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: rgba(0,0,0,0.3); z-index: 9999; display: none; }
        body:fullscreen #fullscreen-lock-overlay, body:-webkit-full-screen #fullscreen-lock-overlay { display: block; }
        #window-network-manager .window-content ul, #window-bluetooth-manager .window-content ul { list-style: none; padding:0; }
        #window-network-manager .window-content li, #window-bluetooth-manager .window-content li { background-color: #e9ecef; padding: 8px; margin-bottom: 5px; border-radius: 4px; display:flex; justify-content: space-between; align-items:center; }
        #window-network-manager .window-content, #window-bluetooth-manager .window-content { padding: 15px; }


        /* PEPx File Explorer Specific Styles */
        #window-pepx-explorer .window-content {
            padding: 0; /* PEPx manages its own internal padding */
            background-color: var(--pepx-bg-color);
            color: var(--pepx-text-color);
            height: 100%; /* Ensure it fills the window content area */
        }
        .pepx-file-manager { display: flex; flex-direction: column; height: 100%; border: none; /* Removed border as it's inside a window */ border-radius: 0; overflow: hidden; }
        .pepx-toolbar { display: flex; padding: 10px; background-color: #f0f0f0; border-bottom: 1px solid var(--pepx-border-color); align-items: center; }
        .pepx-toolbar button { background-color: var(--pepx-primary-color); color: white; border: none; border-radius: 4px; padding: 6px 10px; margin-right: 8px; cursor: pointer; font-size: 0.8rem; }
        .pepx-toolbar button:hover { background-color: var(--pepx-secondary-color); }
        .pepx-toolbar input#pepx-path-display { flex-grow: 1; padding: 6px; border: 1px solid var(--pepx-border-color); border-radius: 4px; font-size: 0.8rem; background-color: var(--pepx-light-bg); color: var(--pepx-text-color); }
        .pepx-file-list { flex-grow: 1; overflow-y: auto; padding: 10px; display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; background-color: var(--pepx-light-bg); }
        .pepx-item { display: flex; flex-direction: column; align-items: center; padding: 8px; cursor: pointer; border-radius: 5px; transition: background-color 0.2s; border: 1px solid transparent; }
        .pepx-item:hover { background-color: rgba(0, 0, 0, 0.05); border-color: var(--pepx-border-color); }
        .pepx-icon { font-size: 28px; margin-bottom: 4px; }
        .pepx-name { text-align: center; font-size: 11px; word-break: break-word; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; line-height:1.2; }
        .pepx-size { font-size: 9px; color: #777; margin-top: 2px; }
        .pepx-status-bar { padding: 6px 10px; background-color: #f0f0f0; border-top: 1px solid var(--pepx-border-color); display: flex; justify-content: space-between; font-size: 11px; color: #555; }
        /* PEPx Modal (re-using OBPI's modal for consistency, but can be styled uniquely if needed) */
        .pepx-modal-body img { max-width: 100%; display: block; margin: 0 auto; border-radius: 4px; }
        .pepx-modal-body pre { white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: var(--font-mono); background-color: #f8f8f8; padding:10px; border-radius:4px; max-height: 60vh; overflow-y:auto; }
        /* PEPx Context Menu (re-using OBPI's for consistency) */

    </style>
</head>
<body>

    <div id="desktop">
        <canvas id="webgl-canvas"></canvas>
        <div id="fullscreen-lock-overlay" class="fullscreen-lock-overlay"></div>
        </div>

    <div class="taskbar">
        <button id="start-menu-button" class="taskbar-button">ðŸš€ OBPI</button>
        <div id="taskbar-apps-container" style="display: flex; margin-left: 10px;"></div>
    </div>
    
    <div id="start-menu" class="hidden">
        </div>

    <div id="context-menu" class="context-menu hidden"></div>

    <div id="generic-modal" class="fixed inset-0 bg-black bg-opacity-60 items-center justify-center z-[15000] hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-md w-full text-gray-800">
            <div class="flex justify-between items-center mb-4">
                <h3 id="modal-title" class="text-xl font-semibold">Modal Title</h3>
                <button id="modal-close-button" class="text-2xl hover:text-red-500">&times;</button>
            </div>
            <div id="modal-content" class="mb-4"><p>Modal content goes here...</p></div>
            <div id="modal-actions" class="flex justify-end space-x-3"></div>
        </div>
    </div>

    <div id="pyscript-global-output" class="hidden"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    // --- OBPI (Operational in Browser Persisted Instance) Core v0.6 (PEPx Integration) ---
    // [2025-05-20]
    // Integrated PEPx File Explorer and Storage System.

    // --- Global State & Configuration ---
    const OBPI = { /* ... as in v0.5 ... */ 
        version: "0.6-pepx",
        name: "Operational in Browser Persisted Instance",
        desktopElement: document.getElementById('desktop'),
        taskbarElement: document.querySelector('.taskbar'),
        taskbarAppsContainer: document.getElementById('taskbar-apps-container'),
        startMenuElement: document.getElementById('start-menu'),
        startMenuButton: document.getElementById('start-menu-button'),
        contextMenuElement: document.getElementById('context-menu'),
        modalElement: document.getElementById('generic-modal'),
        modalTitle: document.getElementById('modal-title'),
        modalContent: document.getElementById('modal-content'),
        modalActions: document.getElementById('modal-actions'),
        modalCloseButton: document.getElementById('modal-close-button'),
        fullscreenLockOverlay: document.getElementById('fullscreen-lock-overlay'),
        windows: {}, 
        nextZIndex: 100,
        fileSystem: null, 
        currentPath: '/home/guest/',
        commandHistory: [],
        commandHistoryIndex: -1,
        isLocked: false, 
        envVars: {}, 
        aliases: {}, 
        activeTheme: 'dark', 
        config: {
            defaultPrompt: 'guest@OBPI:~# ', 
            maxTerminalOutputLines: 300,
            defaultWindowSize: { width: '600px', height: '450px' },
            windowStateStorageKey: 'OBPI_window_states_v0.6', // Updated key
            themeStorageKey: 'OBPI_theme_v0.6', // Updated key
            desktopIconStorageKey: 'OBPI_desktop_icons_v0.6', // Updated key
        },
        kernel: { /* ... as in v0.5 ... */ 
            log: (message, level = 'info') => { console[level] || console.log(`[OBPI Kernel|${level.toUpperCase()}]: ${message}`); },
            loadWasmModule: async (url, importObject = {}) => { OBPI.kernel.log(`Attempting to load WASM module from: ${url}`); try { if (url.includes("core_emulator.wasm")) { OBPI.kernel.log(`Simulating load of core_emulator.wasm...`, 'info'); return { add_native: (a, b) => { OBPI.kernel.log(`WASM add_native(${a}, ${b}) called.`); return a + b; }, get_native_greeting: (name) => { OBPI.kernel.log(`WASM get_native_greeting("${name}") called.`); return `[Simulated C->WASM]: Hello, ${name}! Time: ${new Date().toLocaleTimeString()}`; }, get_system_timestamp_native: () => { OBPI.kernel.log(`WASM get_system_timestamp_native() called.`); return Math.floor(Date.now() / 1000); } }; } throw new Error("WASM module not found or simulated path incorrect."); } catch (error) { OBPI.kernel.log(`Error loading WASM module ${url}: ${error.message}`, 'error'); throw error; } },
            requestPermission: async (permissionType, appName) => { return new Promise((resolve) => { Modal.confirm('Permission Request', `App "${appName}" requests permission for: ${permissionType}. Allow?`, (granted) => { OBPI.kernel.log(`Permission for '${permissionType}' ${granted ? 'granted' : 'denied'} to '${appName}'.`); resolve(granted); }); }); },
            messageBus: { listeners: {}, subscribe: (topic, callback) => { if (!OBPI.kernel.messageBus.listeners[topic]) OBPI.kernel.messageBus.listeners[topic] = []; OBPI.kernel.messageBus.listeners[topic].push(callback); OBPI.kernel.log(`App subscribed to topic: ${topic}`); }, publish: (topic, data) => { if (OBPI.kernel.messageBus.listeners[topic]) { OBPI.kernel.log(`Publishing to topic: ${topic} with data:`, 'info', data); OBPI.kernel.messageBus.listeners[topic].forEach(callback => { try { callback(data); } catch (e) { OBPI.kernel.log(`Error in message bus subscriber for topic ${topic}: ${e.message}`, 'error');} }); } } }
        },
        pepxInstance: null // To hold the global PEPxStorage instance
    };

    // --- Client-Side "EJS-like" Templating Engine ---
    const EJSSimulator = { /* ... as in v0.5 ... */ 
        render: (templateString, data = {}) => { let rendered = templateString; for (const key in data) { const regex = new RegExp(`<%[=\\-_]?\\s*${key}\\s*%>`, 'g'); rendered = rendered.replace(regex, data[key]); } return rendered; },
        exampleTemplate: ` <div class="p-4 border rounded bg-blue-100 text-blue-800"> <h2 class="text-xl font-bold"><%= title %></h2> <p><%= content %></p> <p>Generated at: <%= timestamp %></p> </div> `,
        renderExample: () => { const data = { title: "EJS Simulated Content", content: "Dynamically rendered using EJSSimulator.", timestamp: new Date().toLocaleTimeString() }; return EJSSimulator.render(EJSSimulator.exampleTemplate, data); }
    };

    // --- Modal Manager ---
    const Modal = { /* ... as in v0.5 ... */ 
        show: (title, contentHTML, actions = [{ text: 'OK', type: 'primary', handler: () => Modal.hide() }]) => { OBPI.modalTitle.textContent = title; if (typeof contentHTML === 'string') OBPI.modalContent.innerHTML = contentHTML; else { OBPI.modalContent.innerHTML = ''; OBPI.modalContent.appendChild(contentHTML); } OBPI.modalActions.innerHTML = ''; actions.forEach(action => { const button = document.createElement('button'); button.textContent = action.text; button.className = `px-4 py-2 rounded-md text-sm font-medium ${ action.type === 'danger' ? 'bg-red-500 hover:bg-red-600 text-white' : action.type === 'secondary' ? 'bg-gray-200 hover:bg-gray-300 text-gray-700' : 'bg-indigo-600 hover:bg-indigo-700 text-white' }`; button.onclick = () => { if(action.handler) action.handler(); if(action.hideOnClick !== false) Modal.hide(); }; OBPI.modalActions.appendChild(button); }); OBPI.modalElement.classList.remove('hidden'); OBPI.modalElement.classList.add('flex'); },
        hide: () => { OBPI.modalElement.classList.add('hidden'); OBPI.modalElement.classList.remove('flex'); },
        prompt: (title, labelText, defaultValue = '', callback) => { const promptContent = document.createElement('div'); const label = document.createElement('label'); label.textContent = labelText; label.className = 'block text-sm font-medium text-gray-700 mb-1'; const input = document.createElement('input'); input.type = 'text'; input.value = defaultValue; input.className = 'w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-indigo-500 focus:border-indigo-500'; promptContent.appendChild(label); promptContent.appendChild(input); Modal.show(title, promptContent, [ { text: 'Cancel', type: 'secondary', handler: () => callback(null) }, { text: 'OK', type: 'primary', handler: () => callback(input.value) } ]); setTimeout(() => input.focus(), 50); },
        confirm: (title, message, callback) => { Modal.show(title, `<p>${message}</p>`, [ { text: 'Cancel', type: 'secondary', handler: () => callback(false) }, { text: 'OK', type: 'primary', handler: () => callback(true) } ]); }
    };
    OBPI.modalCloseButton.onclick = Modal.hide;

    // --- WebGL Background ---
    function initWebGLBackground() { /* ... as in v0.5 ... */ 
        try {
            scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000); renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('webgl-canvas'), antialias: true, alpha: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(OBPI.config.bgColor || 0x1a1a2e, 1); const starGeometry = new THREE.BufferGeometry(); const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, sizeAttenuation: true, transparent: true, opacity: 0.7 }); const starVertices = []; for (let i = 0; i < 15000; i++) { const x = THREE.MathUtils.randFloatSpread(2000); const y = THREE.MathUtils.randFloatSpread(2000); const z = THREE.MathUtils.randFloatSpread(2000); starVertices.push(x, y, z); } starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3)); stars = new THREE.Points(starGeometry, starMaterial); scene.add(stars); camera.position.z = 1; function animate() { requestAnimationFrame(animate); stars.rotation.x += 0.00005; stars.rotation.y += 0.0001; renderer.render(scene, camera); } animate(); window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }); OBPI.kernel.log("WebGL background initialized.", "success");
        } catch (e) { OBPI.kernel.log(`WebGL initialization failed: ${e.message}`, "error"); OBPI.desktopElement.style.backgroundColor = OBPI.config.bgColor || '#1a1a2e'; }
    }

    // --- Window Management Module ---
    const WindowManager = { /* ... as in v0.5 ... */ 
        create: (id, title, contentHTML = '', options = {}) => { if (OBPI.windows[id]) { WindowManager.focus(id); return OBPI.windows[id].element; } const windowElement = document.createElement('div'); windowElement.id = `window-${id}`; windowElement.classList.add('os-window'); const defaultSize = OBPI.config.defaultWindowSize; const persistedStates = WindowManager.loadWindowStates(); const state = persistedStates[id] || {}; windowElement.style.width = state.width || options.width || defaultSize.width; windowElement.style.height = state.height || options.height || defaultSize.height; windowElement.style.top = state.top || options.top || `${Math.random() * 80 + 20}px`; windowElement.style.left = state.left || options.left || `${Math.random() * 120 + 20}px`; windowElement.style.zIndex = state.zIndex || OBPI.nextZIndex++; if (state.zIndex && state.zIndex >= OBPI.nextZIndex) OBPI.nextZIndex = state.zIndex + 1; const header = document.createElement('div'); header.classList.add('window-header'); header.innerHTML = `<span class="window-title">${title}</span><div class="window-controls"><button class="minimize-btn" title="Minimize">â”€</button><button class="maximize-btn" title="Maximize">â–¡</button><button class="close-btn" title="Close">Ã—</button></div>`; const content = document.createElement('div'); content.classList.add('window-content'); if (options.isRawHTML) content.innerHTML = contentHTML; else if (typeof contentHTML === 'string' && contentHTML.startsWith('<')) content.innerHTML = contentHTML; else if (contentHTML instanceof HTMLElement) content.appendChild(contentHTML); else if (typeof contentHTML === 'string') { const p = document.createElement('p'); p.textContent = contentHTML; content.appendChild(p); } windowElement.appendChild(header); windowElement.appendChild(content); OBPI.desktopElement.appendChild(windowElement); OBPI.windows[id] = { element: windowElement, title: title, minimized: false, originalRect: null, zIndex: parseInt(windowElement.style.zIndex) }; WindowManager.addAppToTaskbar(id, title); let offsetX, offsetY, isDragging = false; let dragTimeout; header.addEventListener('mousedown', (e) => { if (e.target.closest('.window-controls button')) return; isDragging = true; offsetX = e.clientX - windowElement.offsetLeft; offsetY = e.clientY - windowElement.offsetTop; WindowManager.focus(id); }); document.addEventListener('mousemove', (e) => { if (!isDragging) return; let newX = e.clientX - offsetX; let newY = e.clientY - offsetY; const desktopRect = OBPI.desktopElement.getBoundingClientRect(); const taskbarHeight = OBPI.taskbarElement.offsetHeight; newX = Math.max(0, Math.min(newX, desktopRect.width - windowElement.offsetWidth)); newY = Math.max(0, Math.min(newY, desktopRect.height - windowElement.offsetHeight - taskbarHeight)); windowElement.style.left = `${newX}px`; windowElement.style.top = `${newY}px`; }); document.addEventListener('mouseup', () => { if(isDragging) {isDragging = false; WindowManager.saveWindowStates();} }); const resizeObserver = new ResizeObserver(() => { clearTimeout(dragTimeout); dragTimeout = setTimeout(WindowManager.saveWindowStates, 500); }); resizeObserver.observe(windowElement); header.querySelector('.close-btn').onclick = (e) => { e.stopPropagation(); WindowManager.close(id); }; header.querySelector('.minimize-btn').onclick = (e) => { e.stopPropagation(); WindowManager.minimize(id); }; header.querySelector('.maximize-btn').onclick = (e) => { e.stopPropagation(); WindowManager.maximize(id); }; windowElement.onmousedown = () => WindowManager.focus(id); OBPI.kernel.log(`Window created: ${title} (ID: ${id})`); if (state.minimized) WindowManager.minimize(id); return windowElement; },
        focus: (id) => { if (OBPI.windows[id]) { const newZ = OBPI.nextZIndex++; OBPI.windows[id].element.style.zIndex = newZ; OBPI.windows[id].zIndex = newZ; document.querySelectorAll('.os-window').forEach(win => win.classList.remove('active-window')); OBPI.windows[id].element.classList.add('active-window'); if (OBPI.windows[id].minimized) WindowManager.restore(id); WindowManager.saveWindowStates(); } },
        close: (id) => { if (OBPI.windows[id]) { OBPI.windows[id].element.remove(); delete OBPI.windows[id]; WindowManager.removeAppFromTaskbar(id); WindowManager.saveWindowStates(); OBPI.kernel.log(`Window closed: ${id}`); } },
        minimize: (id) => { if (OBPI.windows[id] && !OBPI.windows[id].minimized) { OBPI.windows[id].element.style.display = 'none'; OBPI.windows[id].minimized = true; const taskbarBtn = document.getElementById(`taskbar-${id}`); if(taskbarBtn) taskbarBtn.style.opacity = '0.7'; WindowManager.saveWindowStates(); } },
        restore: (id) => { if (OBPI.windows[id] && OBPI.windows[id].minimized) { OBPI.windows[id].element.style.display = 'flex'; OBPI.windows[id].minimized = false; const taskbarBtn = document.getElementById(`taskbar-${id}`); if(taskbarBtn) taskbarBtn.style.opacity = '1'; WindowManager.focus(id); } },
        maximize: (id) => { const winData = OBPI.windows[id]; if (!winData) return; const winEl = winData.element; const taskbarHeight = OBPI.taskbarElement.offsetHeight; const maximizeBtn = winEl.querySelector('.maximize-btn'); if (winData.originalRect) { winEl.style.width = winData.originalRect.width; winEl.style.height = winData.originalRect.height; winEl.style.top = winData.originalRect.top; winEl.style.left = winData.originalRect.left; winData.originalRect = null; if(maximizeBtn) maximizeBtn.textContent = 'â–¡'; } else { winData.originalRect = { width: winEl.style.width, height: winEl.style.height, top: winEl.style.top, left: winEl.style.left }; winEl.style.width = '100%'; winEl.style.height = `calc(100% - ${taskbarHeight}px)`; winEl.style.top = '0px'; winEl.style.left = '0px'; if(maximizeBtn) maximizeBtn.textContent = 'â'; } WindowManager.saveWindowStates(); },
        addAppToTaskbar: (id, title) => { const button = document.createElement('button'); button.id = `taskbar-${id}`; button.classList.add('taskbar-button'); button.textContent = title.substring(0, 10) + (title.length > 10 ? 'â€¦' : ''); button.title = title; button.onclick = () => { if (OBPI.windows[id]) { if (OBPI.windows[id].minimized) WindowManager.restore(id); else WindowManager.focus(id); } }; OBPI.taskbarAppsContainer.appendChild(button); },
        removeAppFromTaskbar: (id) => { const button = document.getElementById(`taskbar-${id}`); if (button) button.remove(); },
        saveWindowStates: () => { const states = {}; for (const id in OBPI.windows) { const win = OBPI.windows[id]; if (win.element) { states[id] = { top: win.element.style.top, left: win.element.style.left, width: win.element.style.width, height: win.element.style.height, zIndex: win.zIndex, minimized: win.minimized, }; } } try { localStorage.setItem(OBPI.config.windowStateStorageKey, JSON.stringify(states)); } catch (e) { OBPI.kernel.log('Failed to save window states to localStorage.', 'error'); } },
        loadWindowStates: () => { try { const storedStates = localStorage.getItem(OBPI.config.windowStateStorageKey); return storedStates ? JSON.parse(storedStates) : {}; } catch (e) { OBPI.kernel.log('Failed to load window states from localStorage.', 'error'); return {}; } },
        restoreAllWindowStates: () => { const persistedStates = WindowManager.loadWindowStates(); let maxZ = OBPI.nextZIndex; for (const id in persistedStates) { if (AppManager.installedApps[id] || id === 'terminal' || id === 'welcome-note') { if (persistedStates[id].zIndex > maxZ) maxZ = persistedStates[id].zIndex; } } OBPI.nextZIndex = maxZ +1; OBPI.kernel.log("Window states conceptually loaded. Windows will apply state upon creation if found.", "info"); }
    };

    // --- File System Module ---
    const FileSystem = { /* ... as in v0.5 ... */ 
        FS_STORAGE_KEY: 'OBPI_fs_v0.6', 
        init: () => { const storedFS = localStorage.getItem(FileSystem.FS_STORAGE_KEY); if (storedFS) { try { OBPI.fileSystem = JSON.parse(storedFS); } catch (e) { OBPI.kernel.log(`Error parsing stored file system: ${e.message}. Initializing default.`, "error"); FileSystem.initializeDefault(); } } else { FileSystem.initializeDefault(); } OBPI.kernel.log("File system initialized.", "success"); },
        save: () => { try { localStorage.setItem(FileSystem.FS_STORAGE_KEY, JSON.stringify(OBPI.fileSystem)); } catch (e) { OBPI.kernel.log(`Error saving file system: ${e.message}`, "error"); if (Terminal && Terminal.print) Terminal.print("Warning: Could not save file system changes. Storage might be full."); } },
        initializeDefault: () => { 
            OBPI.fileSystem = { '/': { type: 'dir', children: { 'home': { type: 'dir', children: { 'guest': { type: 'dir', children: { 'Desktop': {type: 'dir', children: {}}, 'documents': { type: 'dir', children: { 'project_plan_v0.6.txt': {type: 'file', content: `Project Plan for OBPI v${OBPI.version}\n- PEPx Storage Integration`} }}, 'downloads': { type: 'dir', children: {}}, 'python_scripts': {type: 'dir', children: {'hello.py': {type:'file', content:'print("Hello from PyScript in OBPI!")\nimport js\njs.OBPI.kernel.log("Python script says hi to kernel!")'}, 'example.obsh': {type:'file', content:'echo "Running OBPI Shell Script"\ndate\nls /home/guest/python_scripts'}}}, 'readme.txt': { type: 'file', content: `Welcome to OBPI (${OBPI.name}) v${OBPI.version}!\nThis is a simulated file system.\nChanges are persisted in your browser's localStorage.` } }} }}, 'bin': { type: 'dir', children: { 'curl': {type: 'file', content: '#!/bin/simulated_executable\n# curl command'}, 'wget': {type: 'file', content: '#!/bin/simulated_executable\n# wget command'}, 'exec': {type: 'file', content:'#!/bin/simulated_executable\n# exec command'} }}, 'etc': { type: 'dir', children: { 'obpi.config': {type: 'file', content: `version=${OBPI.version}\nprompt=${OBPI.config.defaultPrompt}\ntheme=${OBPI.activeTheme}`}, 'hosts.sim': {type:'file', content:'127.0.0.1 localhost.obpi\n10.0.0.1 virtual.server.obpi'} }}, 'tmp': { type: 'dir', children: {}} }} };
            FileSystem.save();
        },
        resolvePath: (pathInput) => { /* ... as in v0.5 ... */ 
            let parts; let currentNode; let currentResolvedPath = [];
            if (pathInput.startsWith('/')) { currentNode = OBPI.fileSystem['/']; parts = pathInput.split('/').filter(p => p.length > 0); } 
            else { currentNode = OBPI.fileSystem['/']; currentResolvedPath = OBPI.currentPath.split('/').filter(p => p.length > 0); for (const part of currentResolvedPath) { if (currentNode.children && currentNode.children[part] && currentNode.children[part].type === 'dir') { currentNode = currentNode.children[part]; } else { return { node: null, name: null, parent: null, error: `Invalid base path segment: ${part}` }; } } parts = pathInput.split('/').filter(p => p.length > 0); }
            let parentNode = null; let lastNamePart = '';
            for (let i = 0; i < parts.length; i++) {
                const part = parts[i]; lastNamePart = part; if (part === '.') continue;
                if (part === '..') { if (currentResolvedPath.length > 0) { currentResolvedPath.pop(); } let tempNode = OBPI.fileSystem['/']; for (const p of currentResolvedPath) { if(tempNode.children && tempNode.children[p]) tempNode = tempNode.children[p]; else { /* handle error or break */ break; } } parentNode = tempNode; currentNode = parentNode; continue; }
                if (currentNode.children && currentNode.children[part]) { parentNode = currentNode; currentNode = currentNode.children[part]; currentResolvedPath.push(part); } 
                else if (i === parts.length - 1) { parentNode = currentNode; currentNode = null; currentResolvedPath.push(part); } 
                else { return { node: null, name: part, parent: parentNode, error: `Path not found: '${part}' in /${currentResolvedPath.join('/')}` }; }
            }
            const finalPath = '/' + currentResolvedPath.join('/'); return { node: currentNode, name: lastNamePart, parent: parentNode, path: finalPath, error: null };
        }
    };

    // --- Terminal Module ---
    const Terminal = { /* ... as in v0.5 ... */ 
        outputElement: null, inputElement: null, promptElement: null,
        init: () => { const terminalContent = document.createElement('div'); terminalContent.className = 'cli-font w-full h-full flex flex-col'; Terminal.outputElement = document.createElement('div'); Terminal.outputElement.id = 'terminal-output'; const inputLine = document.createElement('div'); inputLine.id = 'terminal-input-line'; Terminal.promptElement = document.createElement('span'); Terminal.promptElement.id = 'terminal-prompt'; Terminal.updatePrompt(); Terminal.inputElement = document.createElement('input'); Terminal.inputElement.type = 'text'; Terminal.inputElement.id = 'terminal-input'; Terminal.inputElement.setAttribute('autocomplete', 'off'); Terminal.inputElement.setAttribute('autocorrect', 'off'); Terminal.inputElement.setAttribute('autocapitalize', 'off'); Terminal.inputElement.setAttribute('spellcheck', 'false'); inputLine.appendChild(Terminal.promptElement); inputLine.appendChild(Terminal.inputElement); terminalContent.appendChild(Terminal.outputElement); terminalContent.appendChild(inputLine); const termWindow = WindowManager.create('terminal', 'Termia Chronos Shell', terminalContent, {width: '800px', height: '550px'}); Terminal.inputElement.onkeydown = Terminal.handleInput; termWindow.onclick = () => Terminal.inputElement.focus(); Terminal.inputElement.focus(); Terminal.print(`OBPI (${OBPI.name}) v${OBPI.version} [Termia Chronos Shell Ready]`); Terminal.print("Type 'help' for commands. Try 'theme light' or 'theme dark'."); },
        updatePrompt: () => { if (Terminal.promptElement) { let currentDirName = OBPI.currentPath.split('/').filter(Boolean).pop() || '/'; if (OBPI.currentPath === '/home/guest/') currentDirName = '~'; else if (OBPI.currentPath === '/') currentDirName = '/'; Terminal.promptElement.textContent = OBPI.config.defaultPrompt.replace('~#', `${currentDirName}$ `).replace('guest@OBPI', OBPI.envVars['USER'] || 'guest@OBPI');} },
        print: (message, isCommand = false, type = 'info') => { if (!Terminal.outputElement) return; const line = document.createElement('div'); line.className = 'leading-normal'; if (isCommand) { const promptText = Terminal.promptElement ? Terminal.promptElement.textContent : OBPI.config.defaultPrompt; line.innerHTML = `<span class="text-green-400">${promptText.replace(/</g, "&lt;")}</span><span class="text-gray-300">${message.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</span>`; }  else { let textColor = 'text-gray-300'; if(document.body.classList.contains('light-theme')) { textColor = 'text-gray-700'; if(type==='error') textColor = 'text-red-600'; if(type==='success') textColor = 'text-green-600'; if(type==='warn') textColor = 'text-yellow-600'; } else { if(type === 'error') textColor = 'text-red-400'; if(type === 'success') textColor = 'text-green-400'; if(type === 'warn') textColor = 'text-yellow-400';} line.innerHTML = `<span class="${textColor}">${message.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</span>`; } Terminal.outputElement.prepend(line); while (Terminal.outputElement.children.length > OBPI.config.maxTerminalOutputLines) Terminal.outputElement.removeChild(Terminal.outputElement.lastChild); },
        handleInput: (e) => { if (e.key === 'Enter') { const commandStr = Terminal.inputElement.value.trim(); Terminal.print(commandStr, true); if (commandStr) { if (commandStr !== OBPI.commandHistory[0]) OBPI.commandHistory.unshift(commandStr); if (OBPI.commandHistory.length > 50) OBPI.commandHistory.pop(); AppManager.executeCommand(commandStr); } OBPI.commandHistoryIndex = -1; Terminal.inputElement.value = ''; }  else if (e.key === 'ArrowUp') { e.preventDefault(); if (OBPI.commandHistoryIndex < OBPI.commandHistory.length - 1) { OBPI.commandHistoryIndex++; Terminal.inputElement.value = OBPI.commandHistory[OBPI.commandHistoryIndex]; Terminal.inputElement.setSelectionRange(Terminal.inputElement.value.length, Terminal.inputElement.value.length); } }  else if (e.key === 'ArrowDown') { e.preventDefault(); if (OBPI.commandHistoryIndex > 0) { OBPI.commandHistoryIndex--; Terminal.inputElement.value = OBPI.commandHistory[OBPI.commandHistoryIndex]; Terminal.inputElement.setSelectionRange(Terminal.inputElement.value.length, Terminal.inputElement.value.length); } else { OBPI.commandHistoryIndex = -1; Terminal.inputElement.value = ''; } }  else if (e.key === 'Tab') { e.preventDefault(); const currentInput = Terminal.inputElement.value; const parts = currentInput.split(' '); const cmdPart = parts[0].toLowerCase(); const argPart = parts.length > 1 ? parts[parts.length -1] : ''; if (parts.length === 1 || (parts.length > 1 && currentInput.endsWith(' '))) { /* Command completion */ const suggestions = Object.keys(AppManager.cliCommands).filter(cmd => cmd.startsWith(cmdPart)); if (suggestions.length === 1) Terminal.inputElement.value = suggestions[0] + ' '; else if (suggestions.length > 1) Terminal.print(suggestions.join('  ')); } else { /* Argument (file/dir) completion */ const baseCompletionPath = argPart.startsWith('/') ? argPart : OBPI.currentPath + argPart; let searchDir = baseCompletionPath; let prefix = argPart.split('/').pop(); if (!currentInput.endsWith('/')) searchDir = baseCompletionPath.substring(0, baseCompletionPath.lastIndexOf('/') + 1); else prefix = ''; const {node} = FileSystem.resolvePath(searchDir || OBPI.currentPath); if (node && node.type === 'dir') { const items = Object.keys(node.children).filter(name => name.startsWith(prefix)); if (items.length === 1) { const completion = argPart.substring(0, argPart.lastIndexOf('/') +1) + items[0] + (node.children[items[0]].type === 'dir' ? '/' : ' '); Terminal.inputElement.value = cmdPart + ' ' + completion; } else if (items.length > 1) Terminal.print(items.join('  ')); } } } },
        clear: () => { if(Terminal.outputElement) Terminal.outputElement.innerHTML = ''; }
    };

    // --- PEPx Storage System (Integrated) ---
    class PEPxStorage {
        constructor(dimensions = 19000) { // Default from spec, practical might be smaller
            this.dimensions = Math.min(dimensions, 4096); // Cap dimensions for browser stability
            this.totalPlanes = 9; 
            this.colorChannels = 4; // Using RGBA, 4 channels
            this.bitsPerChannelComponent = 2; // Storing 2 bits per R,G,B,A component (LSB Steganography)
            // Total bits per pixel = 4 channels * 2 bits/channel = 8 bits (1 byte)
            this.canvasElements = [];
            this.metadataStore = new PEPxMetadataStore('pepx_metadata_v0.6'); // Unique key for its metadata
            this.isInitialized = false;
            OBPI.kernel.log(`PEPxStorage: Instantiated with dimensions ${this.dimensions}x${this.dimensions}. Practical capacity will be lower than theoretical.`, 'info');
        }

        async initializeCanvases() {
            if (this.isInitialized) return;
            OBPI.kernel.log(`PEPxStorage: Initializing ${this.totalPlanes} canvas planes...`, 'info');
            for (let i = 0; i < this.totalPlanes; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = this.dimensions;
                canvas.height = this.dimensions;
                // canvas.style.display = 'none'; // Keep hidden
                // document.body.appendChild(canvas); // Not strictly needed if only using ImageData
                
                const ctx = canvas.getContext('2d', { willReadFrequently: true });
                // Initialize with a slightly noisy background to make data less obvious
                for(let y=0; y < this.dimensions; y+=4) {
                    for(let x=0; x < this.dimensions; x+=4) {
                        ctx.fillStyle = `rgb(${Math.floor(Math.random()*10)}, ${Math.floor(Math.random()*10)}, ${Math.floor(Math.random()*10)})`;
                        ctx.fillRect(x,y,4,4);
                    }
                }
                this.canvasElements.push({
                    id: `pepx-plane-${i}`,
                    canvas: canvas,
                    ctx: ctx,
                    // imageData: ctx.getImageData(0, 0, this.dimensions, this.dimensions) // Get ImageData on demand
                });
            }
            this.isInitialized = true;
            OBPI.kernel.log(`PEPxStorage: ${this.totalPlanes} storage planes initialized. Capacity: ${this.calculateCapacity()} bytes.`, 'success');
        }

        calculateCapacity() {
            const pixelsPerPlane = this.dimensions * this.dimensions;
            const bytesPerPixel = (this.colorChannels * this.bitsPerChannelComponent) / 8; // Should be 1 byte per pixel with 2 bits per RGBA component
            const totalBytes = pixelsPerPlane * bytesPerPixel * this.totalPlanes;
            return totalBytes;
        }

        async storeFile(file, path) {
            if (!this.isInitialized) await this.initializeCanvases();
            OBPI.kernel.log(`PEPx: Storing file "${file.name}" to path "${path}"`, 'info');
            try {
                const arrayBuffer = await this.readFileAsArrayBuffer(file);
                // Conceptual compression - for now, direct data
                // const compressedData = await this.compressData(arrayBuffer); 
                const dataToStore = new Uint8Array(arrayBuffer); // Use Uint8Array directly

                const allocation = this.findFreeSpace(dataToStore.byteLength);
                if (!allocation) throw new Error('PEPx: Insufficient storage space.');

                await this.encodeDataToPixels(dataToStore, allocation);
                
                const fileId = this.generateUniqueId();
                this.metadataStore.addFile({
                    id: fileId, name: file.name, path: path, size: file.size,
                    storedByteLength: dataToStore.byteLength, // Actual bytes stored
                    type: file.type, allocation: allocation,
                    created: new Date().toISOString(), modified: new Date().toISOString()
                });
                OBPI.kernel.log(`PEPx: File "${file.name}" stored successfully. ID: ${fileId}`, 'success');
                return fileId;
            } catch (error) { OBPI.kernel.log(`PEPx: Failed to store file "${file.name}": ${error.message}`, 'error'); throw error; }
        }
        
        async retrieveFile(fileId) {
            if (!this.isInitialized) { OBPI.kernel.log("PEPx: Canvases not initialized for retrieval.", "warn"); return null; }
            OBPI.kernel.log(`PEPx: Retrieving file ID "${fileId}"`, 'info');
            const metadata = this.metadataStore.getFile(fileId);
            if (!metadata) throw new Error(`PEPx: File metadata not found for ID: ${fileId}`);
            
            const dataBytes = await this.decodeDataFromPixels(metadata.allocation, metadata.storedByteLength);
            // Conceptual decompression
            // const originalData = await this.decompressData(dataBytes.buffer);
            OBPI.kernel.log(`PEPx: File "${metadata.name}" retrieved successfully.`, 'success');
            return new Blob([dataBytes.buffer], { type: metadata.type });
        }

        findFreeSpace(bytesNeeded) {
            // Simplified allocation: finds the first available block of planes/pixels.
            // A real system needs a sophisticated free space bitmap/manager.
            const pixelsNeeded = bytesNeeded; // Since 1 pixel stores 1 byte with current encoding

            for (let planeIndex = 0; planeIndex < this.totalPlanes; planeIndex++) {
                // Check if this plane has enough space (highly simplified)
                // This mock assumes the plane is empty or has space at the beginning
                const currentPlaneCapacity = this.dimensions * this.dimensions;
                if (pixelsNeeded <= currentPlaneCapacity) { // Simplified check
                    // TODO: Implement actual tracking of used pixels per plane
                    const existingAllocationsOnPlane = Object.values(this.metadataStore.files)
                        .filter(f => f.allocation.plane === planeIndex)
                        .sort((a,b) => (a.allocation.startY * this.dimensions + a.allocation.startX) - (b.allocation.startY * this.dimensions + b.allocation.startX));
                    
                    let currentX = 0;
                    let currentY = 0;

                    if(existingAllocationsOnPlane.length > 0) {
                        const lastAlloc = existingAllocationsOnPlane[existingAllocationsOnPlane.length-1].allocation;
                        currentX = lastAlloc.startX + lastAlloc.pixelCount; // Start after last pixel
                        currentY = lastAlloc.startY;
                        while(currentX >= this.dimensions) {
                            currentX -= this.dimensions;
                            currentY++;
                        }
                    }
                    
                    if (currentY < this.dimensions && (currentY * this.dimensions + currentX + pixelsNeeded <= currentPlaneCapacity) ) {
                         OBPI.kernel.log(`PEPx: Allocating ${pixelsNeeded} pixels on plane ${planeIndex} starting at (${currentX},${currentY})`, 'info');
                        return {
                            plane: planeIndex,
                            startX: currentX,
                            startY: currentY,
                            pixelCount: pixelsNeeded
                        };
                    }
                }
            }
            OBPI.kernel.log(`PEPx: No contiguous free space found for ${bytesNeeded} bytes.`, 'warn');
            return null; // No space found (simplified)
        }

        async encodeDataToPixels(dataBytes, allocation) {
            const { plane, startX, startY, pixelCount } = allocation;
            const planeObj = this.canvasElements[plane];
            if (!planeObj) throw new Error(`PEPx: Invalid plane index ${plane}`);
            
            // Get ImageData for the entire plane for batch update
            let imageData = planeObj.ctx.getImageData(0, 0, this.dimensions, this.dimensions);
            let pixels = imageData.data;
            
            let currentX = startX;
            let currentY = startY;

            for (let i = 0; i < dataBytes.length; i++) {
                if (i >= pixelCount) { OBPI.kernel.log("PEPx Encode: Data length exceeds pixel count allocation.", "warn"); break; }
                const byte = dataBytes[i];
                const pixelOffset = (currentY * this.dimensions + currentX) * 4;

                // Embed 2 bits into each R, G, B, A component's LSBs
                pixels[pixelOffset]     = (pixels[pixelOffset]     & 0xFC) | ((byte >> 6) & 0x03); // Bits 7,6 into R
                pixels[pixelOffset + 1] = (pixels[pixelOffset + 1] & 0xFC) | ((byte >> 4) & 0x03); // Bits 5,4 into G
                pixels[pixelOffset + 2] = (pixels[pixelOffset + 2] & 0xFC) | ((byte >> 2) & 0x03); // Bits 3,2 into B
                pixels[pixelOffset + 3] = (pixels[pixelOffset + 3] & 0xFC) | (byte & 0x03);        // Bits 1,0 into A (ensure alpha is mostly opaque for visibility if ever shown)
                
                currentX++;
                if (currentX >= this.dimensions) {
                    currentX = 0;
                    currentY++;
                    if (currentY >= this.dimensions && i < dataBytes.length -1) { // Check if still more data
                         throw new Error('PEPx Encode: Ran out of plane space during multi-line encoding.');
                    }
                }
            }
            planeObj.ctx.putImageData(imageData, 0, 0);
        }

        async decodeDataFromPixels(allocation, storedByteLength) {
            const { plane, startX, startY, pixelCount } = allocation; // pixelCount here is also byteLength
            const planeObj = this.canvasElements[plane];
            if (!planeObj) throw new Error(`PEPx: Invalid plane index ${plane}`);

            const imageData = planeObj.ctx.getImageData(0, 0, this.dimensions, this.dimensions);
            const pixels = imageData.data;
            const decodedBytes = new Uint8Array(storedByteLength);
            
            let currentX = startX;
            let currentY = startY;

            for (let i = 0; i < storedByteLength; i++) {
                if (i >= pixelCount) { OBPI.kernel.log("PEPx Decode: Byte length exceeds pixel count allocation.", "warn"); break; }
                const pixelOffset = (currentY * this.dimensions + currentX) * 4;
                let byte = 0;
                byte |= (pixels[pixelOffset]     & 0x03) << 6;
                byte |= (pixels[pixelOffset + 1] & 0x03) << 4;
                byte |= (pixels[pixelOffset + 2] & 0x03) << 2;
                byte |= (pixels[pixelOffset + 3] & 0x03);
                decodedBytes[i] = byte;

                currentX++;
                if (currentX >= this.dimensions) {
                    currentX = 0;
                    currentY++;
                     if (currentY >= this.dimensions && i < storedByteLength -1) {
                         throw new Error('PEPx Decode: Ran out of plane space during multi-line decoding.');
                    }
                }
            }
            return decodedBytes;
        }
        
        readFileAsArrayBuffer(file) { /* ... as in spec ... */ return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = reject; reader.readAsArrayBuffer(file); }); }
        async compressData(data) { return data; } // Placeholder
        async decompressData(data) { return data; } // Placeholder
        generateUniqueId() { return 'pepx-' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5); }
    }

    class PEPxMetadataStore {
        constructor(storageKey = 'pepx_metadata_default') {
            this.storageKey = storageKey;
            this.files = {};
            this.loadFromLocalStorage();
        }
        addFile(metadata) { this.files[metadata.id] = metadata; this.saveToLocalStorage(); }
        getFile(fileId) { return this.files[fileId]; }
        deleteFile(fileId) { delete this.files[fileId]; this.saveToLocalStorage(); }
        listFiles(path = '/') { // Adjusted to list items directly under path
             return Object.values(this.files).filter(file => {
                if (path === '/') return !file.path.substring(1).includes('/'); // Root items
                return file.path === path || (file.path.startsWith(path) && file.path.substring(path.length+1).indexOf('/') === -1 && file.path !== path );
            });
        }
        saveToLocalStorage() { try { localStorage.setItem(this.storageKey, JSON.stringify(this.files)); } catch (e) { OBPI.kernel.log(`PEPxMetadata: Failed to save: ${e.message}`, 'error'); } }
        loadFromLocalStorage() { try { const data = localStorage.getItem(this.storageKey); if (data) this.files = JSON.parse(data); } catch (e) { OBPI.kernel.log(`PEPxMetadata: Failed to load: ${e.message}`, 'error'); } }
    }

    class PEPxFileManager {
        constructor(storageInstance) {
            this.storage = storageInstance;
            this.currentPath = '/'; // PEPx internal path
            this.uiContainer = null;
            this.fileListElement = null;
            this.pathDisplayElement = null;
            this.statusElement = null;
        }

        initUI(containerElement) { // containerElement is the window's content div
            this.uiContainer = containerElement;
            this.uiContainer.innerHTML = `
                <div class="pepx-file-manager">
                    <div class="pepx-toolbar">
                        <button id="pepx-back-btn">â¬… Back</button>
                        <button id="pepx-home-btn">ðŸ  Home</button>
                        <input type="text" id="pepx-path-display" value="${this.currentPath}" readonly>
                        <button id="pepx-upload-btn" class="ml-auto">â¬†ï¸ Upload</button>
                        <button id="pepx-new-folder-btn">âž• New Folder</button>
                    </div>
                    <div class="pepx-file-list" id="pepx-file-list-area"></div>
                    <div class="pepx-status-bar">
                        <span id="pepx-status-text">Ready</span>
                        <span id="pepx-item-count">0 items</span>
                    </div>
                </div>
            `;
            this.fileListElement = this.uiContainer.querySelector('#pepx-file-list-area');
            this.pathDisplayElement = this.uiContainer.querySelector('#pepx-path-display');
            this.statusElement = this.uiContainer.querySelector('#pepx-status-text');

            this.uiContainer.querySelector('#pepx-back-btn').onclick = () => this.navigateUp();
            this.uiContainer.querySelector('#pepx-home-btn').onclick = () => this.navigate('/');
            this.uiContainer.querySelector('#pepx-upload-btn').onclick = () => this.showUploadDialog();
            this.uiContainer.querySelector('#pepx-new-folder-btn').onclick = () => this.createNewFolder();
            
            this.fileListElement.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const itemElement = e.target.closest('.pepx-item');
                if (itemElement && itemElement.dataset.id) {
                    const fileId = itemElement.dataset.id;
                    const file = this.storage.metadataStore.getFile(fileId);
                    if (file) this.showFileContextMenu(file, e);
                } else { // Context menu for empty area in file list
                    this.showPathContextMenu(e);
                }
            });

            this.refreshFileList();
        }
        
        async refreshFileList() {
            if (!this.fileListElement || !this.storage || !this.storage.metadataStore) {
                OBPI.kernel.log("PEPxFileManager: UI or storage not ready for refresh.", "warn");
                return;
            }
            // List only items directly under currentPath
            const allFiles = Object.values(this.storage.metadataStore.files);
            const filesInCurrentPath = allFiles.filter(file => {
                if (this.currentPath === '/') {
                    // For root, path should be exactly "/" or like "/filename.txt" (no further slashes)
                    return file.path === '/' || (file.path.startsWith('/') && file.path.substring(1).indexOf('/') === -1);
                } else {
                    // For subdirs, path should be exactly currentPath or currentPath + "/filename.txt"
                    const expectedPrefix = this.currentPath.endsWith('/') ? this.currentPath : this.currentPath + '/';
                    return file.path === this.currentPath || (file.path.startsWith(expectedPrefix) && file.path.substring(expectedPrefix.length).indexOf('/') === -1);
                }
            });


            this.fileListElement.innerHTML = '';
            filesInCurrentPath.sort((a,b) => { // Folders first, then by name
                if (a.type === 'folder' && b.type !== 'folder') return -1;
                if (a.type !== 'folder' && b.type === 'folder') return 1;
                return a.name.localeCompare(b.name);
            });

            filesInCurrentPath.forEach(file => {
                const element = document.createElement('div');
                element.className = 'pepx-item';
                element.dataset.id = file.id;
                element.title = `${file.name}\nType: ${file.type}\nSize: ${this.formatFileSize(file.size)}\nModified: ${new Date(file.modified).toLocaleString()}`;
                
                let icon = 'ðŸ“„'; // Default file
                if (file.type === 'folder') icon = 'ðŸ“';
                else if (file.type.startsWith('image/')) icon = 'ðŸ–¼ï¸';
                else if (file.type.startsWith('video/')) icon = 'ðŸŽ¬';
                else if (file.type.startsWith('audio/')) icon = 'ðŸŽµ';
                else if (file.type.startsWith('application/pdf')) icon = 'ðŸ“œ';
                else if (file.type.includes('zip') || file.type.includes('archive')) icon = 'ðŸ“¦';

                element.innerHTML = `
                    <div class="pepx-icon">${icon}</div>
                    <div class="pepx-name">${file.name}</div>
                    ${file.type !== 'folder' ? `<div class="pepx-size">${this.formatFileSize(file.size)}</div>` : ''}
                `;
                element.ondblclick = () => { // Changed from single click for navigation/open
                    if (file.type === 'folder') this.navigate(file.path === '/' ? `/${file.name}` : `${file.path}/${file.name}`);
                    else this.openFile(file.id);
                };
                this.fileListElement.appendChild(element);
            });
            this.pathDisplayElement.value = this.currentPath;
            this.uiContainer.querySelector('#pepx-item-count').textContent = `${filesInCurrentPath.length} items`;
        }

        navigate(newPath) {
            // Normalize path: ensure it starts with / and doesn't end with / unless it's the root
            if (!newPath.startsWith('/')) newPath = '/' + newPath;
            if (newPath !== '/' && newPath.endsWith('/')) newPath = newPath.slice(0, -1);
            
            this.currentPath = newPath;
            this.refreshFileList();
        }

        navigateUp() {
            if (this.currentPath === '/') return;
            const parts = this.currentPath.split('/').filter(Boolean);
            parts.pop();
            this.navigate(parts.length > 0 ? '/' + parts.join('/') : '/');
        }

        showUploadDialog() {
            const input = document.createElement('input');
            input.type = 'file'; input.multiple = true;
            input.onchange = async () => {
                const files = input.files;
                if (!files || files.length === 0) return;
                this.statusElement.textContent = `Uploading ${files.length} file(s)...`;
                Modal.show("Uploading Files", `Preparing to upload ${files.length} file(s) to PEPx storage at ${this.currentPath}. This might take a while for large files.`, [{text: "Close"}]);

                for (let i = 0; i < files.length; i++) {
                    try {
                        this.statusElement.textContent = `Uploading ${files[i].name}... (${i+1}/${files.length})`;
                        // Determine the correct path for the file within the PEPx structure
                        const filePathInPepx = this.currentPath === '/' ? `/${files[i].name}` : `${this.currentPath}/${files[i].name}`;
                        // The storeFile method needs the base path, not the full file path
                        await this.storage.storeFile(files[i], this.currentPath); 
                    } catch (error) { OBPI.kernel.log(`PEPx: Failed to upload ${files[i].name}: ${error.message}`, 'error'); Modal.show("Upload Error", `Failed to upload ${files[i].name}: ${error.message}`);}
                }
                this.statusElement.textContent = 'Upload complete.';
                Modal.hide(); // Hide progress modal
                this.refreshFileList();
            };
            input.click();
        }
        
        async openFile(fileId) {
            this.statusElement.textContent = 'Loading file...';
            try {
                const metadata = this.storage.metadataStore.getFile(fileId);
                if (!metadata) throw new Error(`File not found: ${fileId}`);
                const blob = await this.storage.retrieveFile(fileId);
                const url = URL.createObjectURL(blob);

                let modalContent;
                if (metadata.type.startsWith('image/')) {
                    modalContent = `<img src="${url}" alt="${metadata.name}" class="pepx-modal-body img">`;
                } else if (metadata.type.startsWith('text/') || metadata.type === 'application/json' || metadata.type === 'application/xml') {
                    const text = await blob.text();
                    modalContent = `<pre class="pepx-modal-body pre">${text.replace(/</g, "&lt;")}</pre>`;
                } else {
                    Modal.confirm("Download File", `Preview not available for "${metadata.name}" (${metadata.type}). Download instead?`, (doDownload) => {
                        if (doDownload) this.downloadFile(url, metadata.name); else URL.revokeObjectURL(url);
                    });
                    this.statusElement.textContent = 'Ready';
                    return;
                }
                Modal.show(metadata.name, modalContent, [{text: 'Close', handler: () => URL.revokeObjectURL(url)}]);
                this.statusElement.textContent = 'Ready';
            } catch (error) { OBPI.kernel.log(`PEPx: Failed to open file ${fileId}: ${error.message}`, 'error'); this.statusElement.textContent = 'Error opening file.'; Modal.show("Error", `Could not open file: ${error.message}`);}
        }
        
        downloadFile(url, name) { /* ... as in spec ... */ const a = document.createElement('a'); a.href = url; a.download = name; a.style.display = 'none'; document.body.appendChild(a); a.click(); document.body.removeChild(a); setTimeout(() => URL.revokeObjectURL(url), 100); }
        
        createNewFolder() {
            Modal.prompt('Create New Folder', 'Enter folder name:', 'New Folder', (folderName) => {
                if (!folderName) return;
                // Path for the new folder itself. Metadata's 'path' should refer to its parent.
                const newFolderPath = this.currentPath === '/' ? `/${folderName}` : `${this.currentPath}/${folderName}`;
                
                // Check if folder already exists at this level
                const existing = Object.values(this.storage.metadataStore.files).find(f => f.path === this.currentPath && f.name === folderName && f.type === 'folder');
                if (existing) { Modal.show("Error", `A folder named "${folderName}" already exists here.`); return; }

                const folderId = this.storage.generateUniqueId();
                this.storage.metadataStore.addFile({
                    id: folderId, name: folderName, 
                    path: newFolderPath, // The folder's own full path
                    parentPath: this.currentPath, // Store parent path for easier listing
                    type: 'folder', size: 0, 
                    created: new Date().toISOString(), modified: new Date().toISOString()
                });
                this.refreshFileList();
                this.statusElement.textContent = `Folder '${folderName}' created.`;
            });
        }

        showPathContextMenu(event) { // Context menu for empty area in file list
            const menuItems = [
                { label: 'New Folder...', action: 'new-folder-here', icon: 'âž•' },
                { label: 'Upload Files...', action: 'upload-here', icon: 'â¬†ï¸' },
                { label: 'Refresh', action: 'refresh-current', icon: 'ðŸ”„' }
            ];
            OBPI.contextMenuElement.innerHTML = '';
            menuItems.forEach(item => {
                const menuItemEl = document.createElement('div');
                menuItemEl.className = 'context-menu-item';
                menuItemEl.innerHTML = `<span class="mr-2">${item.icon}</span> ${item.label}`;
                menuItemEl.onclick = () => {
                    OBPI.contextMenuElement.classList.add('hidden');
                    if (item.action === 'new-folder-here') this.createNewFolder();
                    else if (item.action === 'upload-here') this.showUploadDialog();
                    else if (item.action === 'refresh-current') this.refreshFileList();
                };
                OBPI.contextMenuElement.appendChild(menuItemEl);
            });
            OBPI.contextMenuElement.style.top = `${event.clientY}px`;
            OBPI.contextMenuElement.style.left = `${event.clientX}px`;
            OBPI.contextMenuElement.classList.remove('hidden');
        }

        showFileContextMenu(file, event) {
            const menuItems = [
                { label: 'Open', action: 'open', icon: 'ðŸ“‚' },
                { label: 'Download', action: 'download', icon: 'ðŸ’¾' },
                { label: 'Rename...', action: 'rename', icon: 'âœï¸' },
                { label: 'Delete', action: 'delete', icon: 'ðŸ—‘ï¸' },
                { label: 'Properties', action: 'properties', icon: 'â„¹ï¸'}
            ];
            OBPI.contextMenuElement.innerHTML = '';
            menuItems.forEach(item => {
                const menuItemEl = document.createElement('div');
                menuItemEl.className = 'context-menu-item';
                menuItemEl.innerHTML = `<span class="mr-2">${item.icon}</span> ${item.label}`;
                menuItemEl.onclick = () => {
                    OBPI.contextMenuElement.classList.add('hidden');
                    if (item.action === 'open') this.openFile(file.id);
                    else if (item.action === 'download') this.downloadFileById(file.id);
                    else if (item.action === 'rename') this.renameFile(file.id);
                    else if (item.action === 'delete') this.deleteFile(file.id);
                    else if (item.action === 'properties') this.showFileProperties(file.id);
                };
                OBPI.contextMenuElement.appendChild(menuItemEl);
            });
            OBPI.contextMenuElement.style.top = `${event.clientY}px`;
            OBPI.contextMenuElement.style.left = `${event.clientX}px`;
            OBPI.contextMenuElement.classList.remove('hidden');
        }
        
        async downloadFileById(fileId) { /* ... as in spec, using this.openFile logic for blob retrieval ... */ 
            this.statusElement.textContent = `Preparing download for ${fileId}...`;
             try {
                const metadata = this.storage.metadataStore.getFile(fileId);
                if (!metadata) throw new Error(`File not found: ${fileId}`);
                const blob = await this.storage.retrieveFile(fileId);
                const url = URL.createObjectURL(blob);
                this.downloadFile(url, metadata.name);
                this.statusElement.textContent = 'Download started.';
            } catch (error) { OBPI.kernel.log(`PEPx: Failed to download file ${fileId}: ${error.message}`, 'error'); this.statusElement.textContent = 'Error downloading file.'; Modal.show("Error", `Could not download file: ${error.message}`);}
        }
        renameFile(fileId) { /* ... as in spec ... */ 
            const metadata = this.storage.metadataStore.getFile(fileId); if (!metadata) return;
            Modal.prompt('Rename File/Folder', 'Enter new name:', metadata.name, (newName) => {
                if (newName && newName !== metadata.name) {
                    metadata.name = newName; metadata.modified = new Date().toISOString();
                    // If it's a folder, its path also needs to change in metadata
                    if (metadata.type === 'folder') {
                        const oldPath = metadata.path;
                        const parentPath = oldPath.substring(0, oldPath.lastIndexOf('/'));
                        metadata.path = parentPath === '' ? `/${newName}` : `${parentPath}/${newName}`;
                        // TODO: Update paths of all children if it's a folder (complex recursive update)
                        OBPI.kernel.log("PEPx: Folder rename path update for children is conceptual.", "warn");
                    }
                    this.storage.metadataStore.saveToLocalStorage(); this.refreshFileList();
                    this.statusElement.textContent = `Renamed to '${newName}'.`;
                }
            });
        }
        deleteFile(fileId) { /* ... as in spec ... */ 
            const metadata = this.storage.metadataStore.getFile(fileId); if (!metadata) return;
            Modal.confirm('Delete Item', `Are you sure you want to delete "${metadata.name}"? ${metadata.type === 'folder' ? 'This will also delete all its contents.' : ''}`, (confirmed) => {
                if (confirmed) {
                    if (metadata.type === 'folder') { // Recursive delete for folders
                        const childrenToDelete = Object.values(this.storage.metadataStore.files).filter(f => f.path.startsWith(metadata.path + '/') || f.path === metadata.path);
                        childrenToDelete.forEach(child => this.storage.metadataStore.deleteFile(child.id));
                    }
                    this.storage.metadataStore.deleteFile(fileId);
                    this.refreshFileList(); this.statusElement.textContent = `"${metadata.name}" deleted.`;
                }
            });
        }
        showFileProperties(fileId) {
            const metadata = this.storage.metadataStore.getFile(fileId);
            if (!metadata) { Modal.show("Error", "File properties not found."); return; }
            const content = `
                <p><strong>Name:</strong> ${metadata.name}</p>
                <p><strong>Type:</strong> ${metadata.type}</p>
                <p><strong>Size:</strong> ${this.formatFileSize(metadata.size)} (${metadata.size} bytes)</p>
                <p><strong>Stored Size (PEPx):</strong> ${this.formatFileSize(metadata.storedByteLength || metadata.size)}</p>
                <p><strong>Path:</strong> ${metadata.path}</p>
                <p><strong>ID:</strong> ${metadata.id}</p>
                <p><strong>Created:</strong> ${new Date(metadata.created).toLocaleString()}</p>
                <p><strong>Modified:</strong> ${new Date(metadata.modified).toLocaleString()}</p>
            `;
            Modal.show(`Properties: ${metadata.name}`, content);
        }
        formatFileSize(bytes) { /* ... as in spec ... */ if (bytes === undefined || bytes === null || isNaN(bytes)) return 'N/A'; if (bytes === 0 && typeof bytes === 'number') return '0 B'; const units = ['B', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(1024)); return (bytes / Math.pow(1024, i)).toFixed(2) + ' ' + units[i]; }
    }
    
    // --- Application Manager (Integrate PEPx Explorer) ---
    const AppManager = { /* ... (most from v0.5, add pepx_explorer) ... */ 
        installedApps: { 
            'web_view': { name: 'Web View', launch: () => AppManager.launch('web-view', 'Encapsulated Web View', AppManager.apps.encapsulatedBrowser.init()), icon: 'ðŸŒ' }, 
            'dechex_ide': { name: 'DecHex IDE', launch: () => AppManager.launch('dechex-ide', 'DecHex IDE', AppManager.apps.decHexIDE.init()), icon: 'âš™ï¸' },
            'ai_assistant': { name: 'AI Assistant', launch: () => AppManager.launch('ai-assistant', 'AI Assistant', AppManager.apps.aiAssistant.init()), icon: 'ðŸ¤–' },
            'disk_manager': { name: 'Disk Manager (VFS)', launch: () => AppManager.launch('disk-manager', 'VFS Disk Manager', AppManager.apps.diskManager.init()), icon: 'ðŸ’¾' }, // Renamed for clarity
            'pepx_explorer': { name: 'PEPx Explorer', launch: () => AppManager.launch('pepx-explorer', 'PEPx Pixel Storage Explorer', AppManager.apps.pepxExplorer.init(), {width:'800px', height:'650px'}), icon: 'ðŸ–¼ï¸' }, // New PEPx App
            'ncurses_demo': { name: 'Ncurses Demo', launch: () => AppManager.launch('ncurses-app', 'Ncurses Demo App', AppManager.apps.ncursesApp.init(), {width:'500px', height:'350px'}), icon: 'â£€' },
            'pyscript_runner': { name: 'PyScript Runner', launch: () => AppManager.launch('pyscript-runner', 'PyScript Runner', AppManager.apps.pyScriptRunner.init(), {width:'700px', height:'550px'}), icon: 'ðŸ' },
            'py_ide': { name: 'Python IDE', launch: () => AppManager.launch('py-ide', 'Python IDE', AppManager.apps.pyIDE.init(), {width:'800px', height:'600px'}), icon: 'ðŸ“' },
            'network_manager': { name: 'Network Manager', launch: () => AppManager.launch('network-manager', 'Network Manager', AppManager.apps.networkManager.init()), icon: 'ðŸ“¶' },
            'bluetooth_manager': { name: 'Bluetooth Manager', launch: () => AppManager.launch('bluetooth-manager', 'Bluetooth Manager', AppManager.apps.bluetoothManager.init()), icon: 'ðŸ“±' }, 
            'theme_settings': { name: 'Theme Settings', launch: () => AppManager.apps.themeSettings.launch(), icon: 'ðŸŽ¨' },
            'wasm_core_test': { name: 'WASM Core Test', launch: () => AppManager.apps.wasmCoreTest.run(), icon: 'ðŸ§©' },
            'xml_parser_test': { name: 'XML Parser Test', launch: () => AppManager.apps.xmlParserTest.run(), icon: 'ðŸ“°' },
            'ejs_sim_test': { name: 'EJS Sim Test', launch: () => { const content = EJSSimulator.renderExample(); WindowManager.create('ejs-test-window', 'EJS Simulator Output', content, {width: '500px', height: '300px'}); }, icon: 'ðŸ“„' }
        },
        launch: (id, title, content, options = {}) => WindowManager.create(id, title, content, options),
        executeCommand: async (commandStr) => { /* ... as in v0.5 ... */ 
            let originalCommandStr = commandStr; commandStr = commandStr.replace(/\$([A-Za-z_][A-Za-z0-9_]*)/g, (match, varName) => OBPI.envVars[varName] || ''); const parts = commandStr.split(/\s+/); let command = parts[0].toLowerCase(); const args = parts.slice(1); if (OBPI.aliases[command]) { const aliasCmdStr = OBPI.aliases[command] + (args.length > 0 ? ' ' + args.join(' ') : ''); Terminal.print(`Alias: ${command} -> ${aliasCmdStr}`, false, 'info'); AppManager.executeCommand(aliasCmdStr); return; } const cmdFunc = AppManager.cliCommands[command]; if (cmdFunc) {  try {  if ((command === 'wget' || command === 'curl') && args.includes('&')) { Terminal.print(`Starting '${originalCommandStr.replace(' &', '')}' in background...`, false, 'info'); args.pop(); setTimeout(async () => { Terminal.print(`Background task '${command} ${args.join(' ')}' started. PID (simulated): ${Math.floor(Math.random()*10000)}`, false, 'info'); await cmdFunc(args); Terminal.print(`Background task '${command} ${args.join(' ')}' finished.`, false, 'success'); OBPI.kernel.messageBus.publish('backgroundTaskComplete', { command: command, args: args }); }, 100); } else { await cmdFunc(args); } } catch (e) {  Terminal.print(`Error executing '${command}': ${e.message}`, false, 'error');  OBPI.kernel.log(`CLI Error: ${e.stack}`, 'error');  }  } else { Terminal.print(`Command not found: ${command}. Type 'help'.`, false, 'error'); } Terminal.updatePrompt();
        },
        cliCommands: { /* ... (all from v0.5 + new pepx commands) ... */ 
            help: () => { Terminal.print("OBPI CLI v0.6 - Available Commands:"); Object.keys(AppManager.cliCommands).sort().forEach(cmd => { Terminal.print(`  ${cmd.padEnd(18)} - ${AppManager.cliCommandDescriptions[cmd] || 'No description.'}`); }); },
            date: () => Terminal.print(new Date().toLocaleString()), clear: Terminal.clear, exit: () => WindowManager.close('terminal'), echo: (args) => Terminal.print(args.join(' ')), pwd: () => Terminal.print(OBPI.currentPath),
            ls: (args) => { /* ... */ const pathArg = args[0] || '.'; const {node, error} = FileSystem.resolvePath(pathArg.startsWith('/') ? pathArg : OBPI.currentPath + pathArg); if (error) { Terminal.print(error, false, 'error'); return; } if (node && node.type === 'dir') { const items = Object.keys(node.children).map(item => `${item}${node.children[item].type === 'dir' ? '/' : ''}`); Terminal.print(items.length > 0 ? items.join('  ') : '(empty directory)'); } else if (node && node.type === 'file') { Terminal.print(pathArg.split('/').pop()); } else { Terminal.print(`ls: '${pathArg}': No such file or directory`, false, 'error'); } },
            cd: (args) => { /* ... */ if (!args[0]) { OBPI.currentPath = FileSystem.resolvePath(OBPI.envVars['HOME'] || '/home/guest/').path || '/'; Terminal.updatePrompt(); return; } const targetPath = args[0]; const {node, path, error} = FileSystem.resolvePath(targetPath.startsWith('/') ? targetPath : OBPI.currentPath + targetPath); if (error) { Terminal.print(error, false, 'error'); return; } if (node && node.type === 'dir') { OBPI.currentPath = path.endsWith('/') || path === '/' ? path : path + '/'; } else { Terminal.print(`cd: '${targetPath}': Not a directory`, false, 'error'); } Terminal.updatePrompt();},
            cat: (args) => { /* ... */ if (!args[0]) { Terminal.print("cat: missing file operand", false, 'error'); return; } const {node, error} = FileSystem.resolvePath(args[0].startsWith('/') ? args[0] : OBPI.currentPath + args[0]); if (error) { Terminal.print(error, false, 'error'); return; } if (node && node.type === 'file') { Terminal.print(node.content || '(empty file)'); } else { Terminal.print(`cat: '${args[0]}': Not a file or does not exist`, false, 'error'); } },
            mkdir: (args) => { /* ... */ if (!args[0]) { Terminal.print("mkdir: missing operand", false, 'error'); return; } const dirName = args[0]; if (dirName.includes('/')) { Terminal.print("mkdir: directory name cannot contain '/'", false, 'error'); return; } const {node: parentNode, error: parentError} = FileSystem.resolvePath(OBPI.currentPath); if (parentError || !parentNode || parentNode.type !== 'dir') { Terminal.print(`mkdir: invalid current path: ${OBPI.currentPath}`, false, 'error'); return; } if (parentNode.children[dirName]) { Terminal.print(`mkdir: '${dirName}': File or directory exists`, false, 'error'); return; } parentNode.children[dirName] = { type: 'dir', children: {} }; FileSystem.save(); Terminal.print(`Directory created: ${OBPI.currentPath}${dirName}`, false, 'success'); },
            write: (args) => { /* ... */ if (args.length < 2) { Terminal.print("write: usage: write <filename> \"<text>\"", false, 'error'); return; } const fileName = args[0]; const content = args.slice(1).join(" ").replace(/^"|"$/g, ''); const {node: parentNode, error: parentError} = FileSystem.resolvePath(OBPI.currentPath); if (parentError || !parentNode || parentNode.type !== 'dir') { Terminal.print(`write: invalid current path: ${OBPI.currentPath}`, false, 'error'); return; } if (parentNode.children[fileName] && parentNode.children[fileName].type === 'dir') { Terminal.print(`write: '${fileName}' is a directory.`, false, 'error'); return; } parentNode.children[fileName] = { type: 'file', content: content }; FileSystem.save(); Terminal.print(`Content written to ${OBPI.currentPath}${fileName}`, false, 'success'); },
            run: (args) => { /* ... */ if (!args[0]) { Terminal.print("run: missing app ID", false, 'error'); return; } const appId = args[0].toLowerCase(); if (AppManager.installedApps[appId]) { AppManager.installedApps[appId].launch(); } else { Terminal.print(`run: app '${appId}' not found. Available: ${Object.keys(AppManager.installedApps).join(', ')}`, false, 'error'); } },
            install: (args) => { /* ... */ if (!args[0]) { Terminal.print("install: missing app_url or app_id", false, 'error'); return; } const appIdentifier = args[0]; if (AppManager.installedApps[appIdentifier]) { Terminal.print(`App '${appIdentifier}' is already conceptually available. Use 'run ${appIdentifier}'.`); } else { Terminal.print(`Simulating installation of '${appIdentifier}'... This is a conceptual command.`, false, 'info'); Terminal.print(`For actual new apps, add them to AppManager.installedApps in the source code.`); } },
            curl: async (args) => { /* ... */ if (!args[0]) { Terminal.print("curl: no URL specified", false, 'error'); return; } const url = args[0]; Terminal.print(`Fetching ${url}...`, false, 'info'); try { const response = await fetch(url); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const text = await response.text(); Terminal.print(`Response from ${url}:\n--------------------\n${text.substring(0, 1000)}${text.length > 1000 ? '...' : ''}`); } catch (e) { Terminal.print(`curl error: ${e.message}`, false, 'error'); } },
            wget: async (args) => { /* ... */ if (!args[0]) { Terminal.print("wget: no URL specified", false, 'error'); return; } const url = args[0]; let outputFilename = args.find(arg => arg.startsWith('-O='))?.split('=')[1] || url.split('/').pop() || 'downloaded_file'; if (!outputFilename) outputFilename = 'index.html'; Terminal.print(`Downloading ${url} to ${outputFilename}...`, false, 'info'); try { const response = await fetch(url); if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`); const text = await response.text(); const {node: parentNode } = FileSystem.resolvePath(OBPI.currentPath); if (parentNode && parentNode.type === 'dir') { parentNode.children[outputFilename] = { type: 'file', content: text.substring(0, 5000) + (text.length > 5000 ? "\n... (content truncated)" : "") }; FileSystem.save(); Terminal.print(`Saved to ${OBPI.currentPath}${outputFilename} (content might be truncated).`, false, 'success'); } else { Terminal.print(`wget: Could not save to current path.`, false, 'error'); } } catch (e) { Terminal.print(`wget error: ${e.message}`, false, 'error'); } },
            fs_reset: () => { Modal.confirm("Reset File System", "CAUTION: This will erase all data in the virtual file system. Are you sure?", (ok) => { if(ok) { FileSystem.initializeDefault(); Terminal.print("Virtual file system reset to default.", false, 'warn');} else {Terminal.print("File system reset cancelled.");} }); },
            exec_dh: (args) => { /* ... */ if (!args[0]) { Terminal.print("exec_dh: no code provided.", false, 'error'); return; } try { const result = DecHexLang.interpret(args.join('')); Terminal.print(`DecHex Output:\n${result}`); } catch (e) { Terminal.print(`DecHex Error: ${e.message}`, false, 'error'); } },
            ask_ai: (args) => { /* ... */ if (!args.length) { Terminal.print("ask_ai: No query provided.", false, 'error'); return; } const query = args.join(" ").replace(/^"|"$/g, ''); if (OBPI.windows['ai-assistant']) { AppManager.apps.aiAssistant.handleQuery(query); WindowManager.focus('ai-assistant'); } else { AppManager.installedApps['ai_assistant'].launch(); setTimeout(() => AppManager.apps.aiAssistant.handleQuery(query), 300); } },
            python: (args) => { /* ... */ if (args.length === 0) AppManager.installedApps['pyscript_runner'].launch(); else { const codeToRun = args.join(" "); AppManager.apps.pyScriptRunner.runCode(codeToRun); if (!OBPI.windows['pyscript-runner']) AppManager.installedApps['pyscript_runner'].launch(); WindowManager.focus('pyscript-runner'); } },
            run_py_file: (args) => { /* ... */ if (!args[0]) { Terminal.print("run_py_file: missing file path", false, 'error'); return; } const filePath = args[0].startsWith('/') ? args[0] : OBPI.currentPath + args[0]; const {node, error} = FileSystem.resolvePath(filePath); if (error) { Terminal.print(`run_py_file: ${error}`, false, 'error'); return; } if (node && node.type === 'file') { Terminal.print(`Executing Python file: ${filePath}`, false, 'info'); AppManager.apps.pyScriptRunner.runCode(node.content); if (!OBPI.windows['pyscript-runner']) AppManager.installedApps['pyscript_runner'].launch(); WindowManager.focus('pyscript-runner'); } else { Terminal.print(`run_py_file: '${args[0]}' not a file or does not exist.`, false, 'error'); } },
            lock_instance: () => { /* ... */ if (OBPI.desktopElement.requestFullscreen) OBPI.desktopElement.requestFullscreen(); else if (OBPI.desktopElement.webkitRequestFullscreen) OBPI.desktopElement.webkitRequestFullscreen(); else if (OBPI.desktopElement.msRequestFullscreen) OBPI.desktopElement.msRequestFullscreen(); OBPI.isLocked = true; OBPI.fullscreenLockOverlay.style.display = 'block'; Terminal.print("OBPI instance screen lock requested. Press ESC to exit fullscreen (browser default). Use 'unlock_instance' if OBPI controls it.", false, 'warn'); },
            unlock_instance: () => { /* ... */ if (document.exitFullscreen) document.exitFullscreen(); else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); else if (document.msExitFullscreen) document.msExitFullscreen(); OBPI.isLocked = false; OBPI.fullscreenLockOverlay.style.display = 'none'; Terminal.print("OBPI instance screen unlock requested.", false, 'info'); },
            export: (args) => { /* ... as in v0.5 ... */ if (!args[0]) { Terminal.print("export: usage: export VAR_NAME=value", false, 'error'); return; } const [name, ...valueParts] = args.join(" ").split('='); if (!name || valueParts.length === 0) { Terminal.print("export: invalid format. Use VAR_NAME=value", false, 'error'); return; } const value = valueParts.join('='); OBPI.envVars[name.trim()] = value.trim().replace(/^["']|["']$/g, ''); Terminal.print(`Set ${name.trim()}=${OBPI.envVars[name.trim()]}`, false, 'success'); if(name.trim() === 'PROMPT') OBPI.config.defaultPrompt = OBPI.envVars[name.trim()]; Terminal.updatePrompt(); },
            unset: (args) => { /* ... as in v0.5 ... */ if (!args[0]) { Terminal.print("unset: usage: unset VAR_NAME", false, 'error'); return; } const varName = args[0].trim(); if (OBPI.envVars.hasOwnProperty(varName)) { delete OBPI.envVars[varName]; Terminal.print(`Unset ${varName}`, false, 'success'); if(varName === 'PROMPT') OBPI.config.defaultPrompt = 'guest@OBPI:~# '; Terminal.updatePrompt(); } else { Terminal.print(`unset: variable not found: ${varName}`, false, 'warn'); } },
            env: () => { /* ... as in v0.5 ... */ Terminal.print("Environment Variables:"); for (const key in OBPI.envVars) Terminal.print(`  ${key}=${OBPI.envVars[key]}`); if (Object.keys(OBPI.envVars).length === 0) Terminal.print("(No environment variables set)"); },
            alias: (args) => { /* ... as in v0.5 ... */ if (args.length === 0) { Terminal.print("Current Aliases:"); for (const key in OBPI.aliases) Terminal.print(`  alias ${key}='${OBPI.aliases[key]}'`); if (Object.keys(OBPI.aliases).length === 0) Terminal.print("(No aliases defined)"); return; } const aliasStr = args.join(" "); const match = aliasStr.match(/^([a-zA-Z0-9_-]+)='(.+)'$/); if (match && match[1] && match[2]) { OBPI.aliases[match[1]] = match[2]; Terminal.print(`Alias set: ${match[1]} -> ${match[2]}`, false, 'success'); } else { Terminal.print("alias: usage: alias name='command string'", false, 'error'); } },
            unalias: (args) => { /* ... as in v0.5 ... */ if (!args[0]) { Terminal.print("unalias: usage: unalias <alias_name>", false, 'error'); return; } const aliasName = args[0]; if (OBPI.aliases[aliasName]) { delete OBPI.aliases[aliasName]; Terminal.print(`Alias removed: ${aliasName}`, false, 'success'); } else { Terminal.print(`unalias: alias not found: ${aliasName}`, false, 'warn'); } },
            exec: async (args) => { /* ... as in v0.5 ... */ if (!args[0]) { Terminal.print("exec: missing file path", false, 'error'); return; } const filePath = args[0].startsWith('/') ? args[0] : OBPI.currentPath + args[0]; const {node, error} = FileSystem.resolvePath(filePath); if (error || !node || node.type !== 'file') { Terminal.print(`exec: cannot access '${args[0]}': No such file or not a regular file.`, false, 'error'); return; } Terminal.print(`Attempting to execute: ${filePath}`, false, 'info'); const fileContent = node.content; const fileExtension = args[0].split('.').pop().toLowerCase(); const hasExecPerm = await OBPI.kernel.requestPermission('execute_file', `File: ${args[0]}`); if (!hasExecPerm) { Terminal.print(`Execution denied for ${args[0]} by OBPI kernel.`, false, 'warn'); return; } if (fileExtension === 'py') AppManager.cliCommands.run_py_file(args); else if (fileExtension === 'js') { Terminal.print(`Executing JavaScript file (conceptual): ${args[0]}`); try { eval(fileContent); Terminal.print(`JavaScript execution finished for ${args[0]}.`, false, 'success'); } catch (e) { Terminal.print(`Error executing JS ${args[0]}: ${e.message}`, false, 'error'); } } else if (fileExtension === 'obsh') { Terminal.print(`Executing OBPI Shell Script: ${args[0]}`, false, 'info'); const commands = fileContent.split('\n').filter(cmd => cmd.trim() && !cmd.trim().startsWith('#')); for (const cmd of commands) { Terminal.print(`$ ${cmd}`, true); await AppManager.executeCommand(cmd); } Terminal.print(`Finished executing script ${args[0]}.`, false, 'success'); } else if (fileExtension === 'dechex' || fileExtension === 'dh') AppManager.cliCommands.exec_dh([fileContent]); else if (fileExtension === 'wasm') Terminal.print(`Conceptual execution of WASM file: ${args[0]}. Use 'wasm_core_test' for now.`, false, 'info'); else Terminal.print(`exec: unknown file type or unsupported extension: .${fileExtension}`, false, 'error'); },
            net: async (args) => { /* ... as in v0.5 ... */ if (!args[0]) { Terminal.print("net: missing subcommand (e.g., scan, connect, info)", false, 'error'); return; } const subCommand = args[0].toLowerCase(); if (subCommand === 'scan') { Terminal.print("Scanning for virtual WiFi networks...", false, 'info'); const hasNetPerm = await OBPI.kernel.requestPermission('network_scan', 'NetworkManagerCLI'); if (!hasNetPerm) { Terminal.print("Network scan permission denied.", false, 'warn'); return; } setTimeout(() => { const networks = AppManager.apps.networkManager.getSimulatedNetworks(); networks.forEach(net => Terminal.print(`  SSID: ${net.ssid.padEnd(20)} Signal: ${net.signal}%  Security: ${net.security}`)); Terminal.print("Scan complete.", false, 'success'); }, 1500); } else if (subCommand === 'connect') { if (!args[1]) { Terminal.print("net connect: missing SSID", false, 'error'); return; } Terminal.print(`Attempting to connect to virtual network: ${args[1]}...`, false, 'info'); const hasNetPerm = await OBPI.kernel.requestPermission('network_connect', 'NetworkManagerCLI'); if (!hasNetPerm) { Terminal.print("Network connect permission denied.", false, 'warn'); return; } setTimeout(() => { const success = Math.random() > 0.3; if (success) { OBPI.envVars['CURRENT_SSID'] = args[1]; Terminal.print(`Successfully connected to ${args[1]}. IP (simulated): 192.168.1.${Math.floor(Math.random()*253)+2}`, false, 'success'); } else Terminal.print(`Failed to connect to ${args[1]}.`, false, 'error'); }, 2000); } else if (subCommand === 'info') { Terminal.print("Simulated Network Interface Info:"); Terminal.print(`  Status: ${OBPI.envVars['CURRENT_SSID'] ? 'Connected' : 'Disconnected'}`); if (OBPI.envVars['CURRENT_SSID']) Terminal.print(`  SSID: ${OBPI.envVars['CURRENT_SSID']}`); Terminal.print(`  MAC Address (simulated): FA:KE:MA:C0:AD:DR`); } else Terminal.print(`net: unknown subcommand '${subCommand}'. Try 'scan', 'connect <ssid>', or 'info'.`, false, 'error'); },
            bt: async (args) => { /* ... as in v0.5 ... */ if (!args[0]) { Terminal.print("bt: missing subcommand (e.g., scan, pair, info)", false, 'error'); return; } const subCommand = args[0].toLowerCase(); if (subCommand === 'scan') { Terminal.print("Scanning for virtual Bluetooth devices...", false, 'info'); const hasBtPerm = await OBPI.kernel.requestPermission('bluetooth_scan', 'BluetoothManagerCLI'); if (!hasBtPerm) { Terminal.print("Bluetooth scan permission denied.", false, 'warn'); return; } setTimeout(() => { const devices = AppManager.apps.bluetoothManager.getSimulatedDevices(); devices.forEach(dev => Terminal.print(`  Device: ${dev.name.padEnd(20)} Type: ${dev.type}`)); Terminal.print("Scan complete.", false, 'success'); }, 1500); } else if (subCommand === 'pair') { if (!args[1]) { Terminal.print("bt pair: missing device name", false, 'error'); return; } Terminal.print(`Attempting to pair with virtual device: ${args[1]}...`, false, 'info'); const hasBtPerm = await OBPI.kernel.requestPermission('bluetooth_pair', 'BluetoothManagerCLI'); if (!hasBtPerm) { Terminal.print("Bluetooth pair permission denied.", false, 'warn'); return; } setTimeout(() => { const success = Math.random() > 0.4; if (success) Terminal.print(`Successfully paired with ${args[1]}.`, false, 'success'); else Terminal.print(`Failed to pair with ${args[1]}.`, false, 'error'); }, 2000); } else Terminal.print(`bt: unknown subcommand '${subCommand}'. Try 'scan' or 'pair <name>'.`, false, 'error'); },
            theme: (args) => { /* ... as in v0.5 ... */ if (!args[0] || (args[0] !== 'light' && args[0] !== 'dark')) { Terminal.print("theme: usage: theme <light|dark>", false, 'error'); Terminal.print(`Current theme: ${OBPI.activeTheme}`); return; } AppManager.apps.themeSettings.setTheme(args[0]); Terminal.print(`Theme set to ${args[0]}.`, false, 'success'); },
            // PEPx CLI commands (conceptual)
            pepx: async (args) => {
                if (!OBPI.pepxInstance) {
                    OBPI.pepxInstance = new PEPxStorage(); // Use default dimensions or load from config
                    await OBPI.pepxInstance.initializeCanvases(); // Ensure canvases are ready
                }
                if (!args[0]) { Terminal.print("pepx: missing subcommand (e.g., ls, stat, upload <local_file_ref> <pepx_path>)", false, 'error'); return; }
                const subCmd = args[0].toLowerCase();
                const pepxPath = args[1] || '/'; // Default to root for ls

                if (subCmd === 'ls') {
                    Terminal.print(`PEPx Listing for path: ${pepxPath}`, false, 'info');
                    const files = OBPI.pepxInstance.metadataStore.listFiles(pepxPath);
                     if(files.length === 0) Terminal.print("(empty or path not found in PEPx store)");
                    files.forEach(f => Terminal.print(`  ${f.name}${f.type === 'folder' ? '/' : ''} (${f.type}, ${AppManager.apps.pepxExplorer.fileManager.formatFileSize(f.size)})`));
                } else if (subCmd === 'stat') {
                    Terminal.print(`PEPx Storage Stats:`, false, 'info');
                    Terminal.print(`  Theoretical Capacity: ${AppManager.apps.pepxExplorer.fileManager.formatFileSize(OBPI.pepxInstance.calculateCapacity())}`);
                    const allFiles = Object.values(OBPI.pepxInstance.metadataStore.files);
                    const totalUsed = allFiles.reduce((sum, f) => sum + (f.storedByteLength || f.size), 0);
                    Terminal.print(`  Total Stored (Metadata): ${AppManager.apps.pepxExplorer.fileManager.formatFileSize(totalUsed)} across ${allFiles.length} files/folders.`);
                } else if (subCmd === 'upload') {
                     Terminal.print("pepx upload: This CLI command is conceptual. Please use the 'PEPx Explorer' app's Upload button.", false, 'warn');
                     Terminal.print("Reason: Direct file access from JS CLI to local user files is restricted by browser security.");
                } else {
                    Terminal.print(`pepx: unknown subcommand '${subCmd}'.`, false, 'error');
                }
            }
        },
        cliCommandDescriptions: { /* ... (update with new commands) ... */ 
            help: "Show this help message.", date: "Display the current date and time.", clear: "Clear the terminal screen.", exit: "Close the terminal window.", echo: "Display a line of text.", pwd: "Print name of current/working directory.", ls: "List directory contents (VFS).", cd: "Change the current directory (VFS).", cat: "Concatenate files and print on the standard output (VFS).", mkdir: "Create a new directory (VFS).", write: "Write text to a file (VFS). Usage: write <filename> \"text\"", run: "Launch a pre-defined application. Usage: run <app_id>", install: "Conceptually 'install' an application. Usage: install <app_id_or_url>", curl: "Transfer data from or to a server. Usage: curl <url> [& for background]", wget: "Download files from the network. Usage: wget <url> [-O=filename] [& for background]", fs_reset: "Reset the VFS file system to its default state.", exec_dh: "Execute DecHex language code. Usage: exec_dh <hex_code_string>", ask_ai: "Send a query to the AI Assistant. Usage: ask_ai \"your question\"",
            python: "Open PyScript Runner or execute Python code directly. Usage: python \"print('hello')\"",
            run_py_file: "Execute a Python script from the VFS. Usage: run_py_file <path/to/script.py>",
            lock_instance: "Request fullscreen lock for the OBPI instance.",
            unlock_instance: "Request to exit fullscreen lock.",
            export: "Set an environment variable. Usage: export VAR=value",
            unset: "Unset an environment variable. Usage: unset VAR",
            env: "Display environment variables.",
            alias: "Define or display command aliases. Usage: alias name='command'",
            unalias: "Remove an alias. Usage: unalias <name>",
            exec: "Execute a file from VFS based on its extension (.py, .js, .obsh, .dechex). Usage: exec <filepath>",
            net: "Simulated network commands. Usage: net <scan|connect|info>",
            bt: "Simulated Bluetooth commands. Usage: bt <scan|pair>",
            theme: "Change OBPI theme. Usage: theme <light|dark>",
            pepx: "Interact with PEPx pixel storage. Usage: pepx <ls|stat|upload...>",
            wasm_test: "Run a test of conceptual WebAssembly module loading.", xml_parser_test: "Run a test of the built-in XML parser.", ejs_sim_test: "Show an example of client-side EJS simulation."
        },
        apps: { /* ... (all from v0.5 + new pepxExplorer) ... */ 
            encapsulatedBrowser: { /* ... as in v0.5 ... */ init: (initialUrl = 'https://duckduckgo.com') => { const content = document.createElement('div'); content.className = 'w-full h-full flex flex-col bg-white'; const searchBarContainer = document.createElement('div'); searchBarContainer.className = 'p-2 border-b flex items-center gap-2 text-sm'; searchBarContainer.innerHTML = ` <button class="back-btn px-2 py-1 bg-gray-200 rounded hover:bg-gray-300" title="Back">â†</button> <button class="fwd-btn px-2 py-1 bg-gray-200 rounded hover:bg-gray-300" title="Forward">â†’</button> <button class="refresh-btn px-2 py-1 bg-gray-200 rounded hover:bg-gray-300" title="Refresh">â†»</button> <input type="text" class="url-input flex-grow border px-2 py-1 rounded" placeholder="Enter URL or search query..." value="${initialUrl.startsWith('http') ? initialUrl : ''}"> <button class="go-btn px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">Go</button> `; const iframe = document.createElement('iframe'); iframe.className = 'flex-grow border-none'; iframe.sandbox = "allow-forms allow-modals allow-pointer-lock allow-popups allow-presentation allow-same-origin allow-scripts"; const urlInput = searchBarContainer.querySelector('.url-input'); const goAction = () => { let query = urlInput.value.trim(); if (!query.startsWith('http://') && !query.startsWith('https://') && query.includes('.')) query = 'https://' + query; else if (!query.startsWith('http://') && !query.startsWith('https://')) query = `https://duckduckgo.com/?q=${encodeURIComponent(query)}`; iframe.src = query; }; if (initialUrl) { if (initialUrl.startsWith('http')) urlInput.value = initialUrl; else urlInput.value = `https://duckduckgo.com/?q=${encodeURIComponent(initialUrl)}`; iframe.src = urlInput.value; } searchBarContainer.querySelector('.back-btn').onclick = () => { try {iframe.contentWindow.history.back();} catch(e){} }; searchBarContainer.querySelector('.fwd-btn').onclick = () => { try {iframe.contentWindow.history.forward();} catch(e){} }; searchBarContainer.querySelector('.refresh-btn').onclick = () => { try {iframe.contentWindow.location.reload();} catch(e){} }; searchBarContainer.querySelector('.go-btn').onclick = goAction; urlInput.onkeypress = (e) => { if (e.key === 'Enter') goAction(); }; content.appendChild(searchBarContainer); content.appendChild(iframe); return content; } },
            decHexIDE: { /* ... as in v0.5 ... */ init: () => { const content = document.createElement('div'); content.className = 'p-3 cli-font h-full flex flex-col'; content.innerHTML = `<h3 class="text-lg font-semibold mb-2 text-gray-800">DecHex Language IDE v0.3</h3> <p class="text-xs mb-2 text-gray-600">Opcodes: 0A=ADD, 0B=SUB, 0C=PRINT_ACC, 0D=LOAD, 0E=PUSH, 0F=POP, 10=PEEK_STACK, 11=JMP_IF_ZERO(addr), 12=STORE_ACC(addr), 13=LOAD_ACC(addr)</p> <textarea class="code-area w-full p-2 border rounded mb-2 bg-gray-50 text-sm flex-grow" rows="8" placeholder="e.g., 0D05 0E 0D0A 0A01 0E 0F 0C"></textarea> <button class="run-btn px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 self-start mb-2">Run Code</button> <pre class="output-area w-full p-2 border rounded bg-gray-800 text-green-300 flex-grow overflow-auto text-xs">Output...</pre>`; const codeArea = content.querySelector('.code-area'); const outputArea = content.querySelector('.output-area'); content.querySelector('.run-btn').onclick = () => { try { outputArea.textContent = DecHexLang.interpret(codeArea.value); } catch (e) { outputArea.textContent = `Error: ${e.message}`; } }; return content; } },
            aiAssistant: { /* ... as in v0.5 ... */ chatOutputElement: null, inputElement: null, init: () => { const content = document.createElement('div'); content.className = 'w-full h-full flex flex-col'; AppManager.apps.aiAssistant.chatOutputElement = document.createElement('div'); AppManager.apps.aiAssistant.chatOutputElement.id = 'ai-chat-output'; const inputArea = document.createElement('div'); inputArea.id = 'ai-input-area'; AppManager.apps.aiAssistant.inputElement = document.createElement('input'); AppManager.apps.aiAssistant.inputElement.type = 'text'; AppManager.apps.aiAssistant.inputElement.id = 'ai-input'; AppManager.apps.aiAssistant.inputElement.placeholder = 'Ask the assistant...'; AppManager.apps.aiAssistant.inputElement.onkeypress = (e) => { if (e.key === 'Enter' && AppManager.apps.aiAssistant.inputElement.value.trim()) { AppManager.apps.aiAssistant.handleQuery(AppManager.apps.aiAssistant.inputElement.value.trim()); AppManager.apps.aiAssistant.inputElement.value = ''; } }; const sendButton = document.createElement('button'); sendButton.id = 'ai-send-button'; sendButton.textContent = 'Send'; sendButton.onclick = () => { if (AppManager.apps.aiAssistant.inputElement.value.trim()) { AppManager.apps.aiAssistant.handleQuery(AppManager.apps.aiAssistant.inputElement.value.trim()); AppManager.apps.aiAssistant.inputElement.value = ''; } }; inputArea.appendChild(AppManager.apps.aiAssistant.inputElement); inputArea.appendChild(sendButton); content.appendChild(AppManager.apps.aiAssistant.chatOutputElement); content.appendChild(inputArea); AppManager.apps.aiAssistant.addMessage("Conceptual AI Assistant v0.3 ready.", 'assistant'); return content; }, addMessage: (text, sender) => { if (!AppManager.apps.aiAssistant.chatOutputElement) return; const msgDiv = document.createElement('div'); msgDiv.classList.add('ai-message', sender); msgDiv.textContent = text; AppManager.apps.aiAssistant.chatOutputElement.appendChild(msgDiv); AppManager.apps.aiAssistant.chatOutputElement.scrollTop = AppManager.apps.aiAssistant.chatOutputElement.scrollHeight; }, handleQuery: (query) => { AppManager.apps.aiAssistant.addMessage(query, 'user'); let response = "I am processing your request..."; const lowerQuery = query.toLowerCase(); if (lowerQuery.includes("time")) response = `Current time: ${new Date().toLocaleTimeString()}`; else if (lowerQuery.includes("date")) response = `Today is: ${new Date().toLocaleDateString()}`; else if (lowerQuery.startsWith("cli:")) { const cmdToRun = query.substring(4).trim(); Terminal.print(`AI request to run: ${cmdToRun}`); AppManager.executeCommand(cmdToRun); response = `Attempted to execute '${cmdToRun}' in terminal.`; } else if (lowerQuery.includes("hello") || lowerQuery.includes("hi")) { response = "Hello! How can I assist you further?"; } else { response = `I'm still learning. I received: "${query.substring(0,30)}..."`; } setTimeout(() => AppManager.apps.aiAssistant.addMessage(response, 'assistant'), 600); } },
            diskManager: { /* ... as in v0.5 ... */ init: () => { const content = document.createElement('div'); content.id = 'disk-manager-content'; content.innerHTML = `<h3 class="text-lg font-semibold mb-3">Virtual Disk Management (VFS)</h3>`; const createVolButton = document.createElement('button'); createVolButton.textContent = 'Create New Virtual Volume'; createVolButton.className = 'px-3 py-1.5 bg-green-500 text-white rounded hover:bg-green-600 text-sm mb-3'; createVolButton.onclick = () => { Modal.prompt('Create Volume', 'Enter volume name (e.g., my_data):', 'new_volume', (name) => { if (name) { const {node: rootNode} = FileSystem.resolvePath('/'); if (rootNode.children[name]) { Modal.show('Error', `A file or directory named '${name}' already exists at the root.`, [{text:'OK'}]); } else { rootNode.children[name] = { type: 'dir', children: {'info.txt': {type:'file', content:`Virtual Volume '${name}' created on ${new Date().toLocaleString()}`}} }; FileSystem.save(); AppManager.apps.diskManager.renderVolumes(content); Terminal.print(`Virtual volume '${name}' created at root.`, false, 'success'); } } }); }; content.appendChild(createVolButton); AppManager.apps.diskManager.renderVolumes(content); return content; }, renderVolumes: (container) => { let volumesList = container.querySelector('.volumes-list'); if (!volumesList) { volumesList = document.createElement('div'); volumesList.className = 'volumes-list mt-2'; container.appendChild(volumesList); } volumesList.innerHTML = ''; const { node: root } = FileSystem.resolvePath('/'); if (root && root.children) { Object.keys(root.children).forEach(itemName => { if (root.children[itemName].type === 'dir') { const volDiv = document.createElement('div'); volDiv.className = 'volume-item'; volDiv.innerHTML = `<strong>${itemName}/</strong> (Virtual Volume) <button data-volname="${itemName}" class="delete-vol-btn text-xs text-red-500 hover:text-red-700 ml-2 p-1">Delete</button>`; volumesList.appendChild(volDiv); } }); } volumesList.querySelectorAll('.delete-vol-btn').forEach(btn => { btn.onclick = (e) => { const volName = e.target.dataset.volname; Modal.confirm('Delete Volume', `Are you sure you want to delete the virtual volume '${volName}' and all its contents? This cannot be undone.`, (confirmed) => { if (confirmed) { const {node: rootNode} = FileSystem.resolvePath('/'); if (rootNode.children[volName]) { delete rootNode.children[volName]; FileSystem.save(); AppManager.apps.diskManager.renderVolumes(container); Terminal.print(`Virtual volume '${volName}' deleted.`, false, 'warn'); } } }); }; }); } },
            ncursesApp: { /* ... as in v0.5 ... */ init: () => { const content = document.createElement('div'); content.id = 'ncurses-display-area'; content.style.cssText = 'width:100%; height:100%; display:grid; grid-template-columns: repeat(var(--cols, 80), 1fr); grid-template-rows: repeat(var(--rows, 24), 1fr); font-size: 14px; line-height: 1.1;'; content.style.setProperty('--cols', 80); content.style.setProperty('--rows', 24); for (let r = 0; r < 24; r++) { for (let c = 0; c < 80; c++) { const charCell = document.createElement('span'); charCell.className = 'ncurses-char'; let char = ' '; if (r === 0 || r === 23) char = (c === 0 || c === 79) ? '+' : '-'; else if (c === 0 || c === 79) char = '|'; const title = "Ncurses Demo App"; if (r === 2 && c > 2 && c < (3 + title.length) ) char = title[c-3]; if (r === 5 && c === 5) char = 'H'; if (r === 5 && c === 6) char = 'e'; if (r === 5 && c === 7) char = 'l'; if (r === 5 && c === 8) char = 'l'; if (r === 5 && c === 9) char = 'o'; charCell.textContent = char; content.appendChild(charCell); } } return content; } },
            wasmCoreTest: { /* ... as in v0.5 ... */ run: async () => { Terminal.print("Running WASM Core Test...", false, 'info'); try { const coreModule = await OBPI.kernel.loadWasmModule('conceptual/core_emulator.wasm'); if (coreModule && coreModule.add_native && coreModule.get_native_greeting) { const sum = coreModule.add_native(15, 27); Terminal.print(`WASM: add_native(15, 27) = ${sum}`, false, 'success'); const greeting = coreModule.get_native_greeting("OBPI User"); Terminal.print(`WASM: ${greeting}`, false, 'success'); const ts = coreModule.get_system_timestamp_native(); Terminal.print(`WASM: get_system_timestamp_native() = ${ts} (Unix Timestamp)`, false, 'success'); } else { Terminal.print("WASM core module or its functions not found (simulated).", false, 'error'); } } catch (e) { Terminal.print(`WASM Core Test Error: ${e.message}`, false, 'error'); } } },
            xmlParserTest: { /* ... as in v0.5 ... */ run: () => { const xmlString = `<note><to>User</to><from>OBPI</from><heading>Reminder</heading><body>Test XML Parsing!</body></note>`; Terminal.print(`Parsing XML: ${xmlString.replace(/</g, "&lt;")}`, false, 'info'); try { const parser = new DOMParser(); const xmlDoc = parser.parseFromString(xmlString, "text/xml"); const parserError = xmlDoc.getElementsByTagName("parsererror"); if (parserError.length > 0) throw new Error("XML parsing error: " + parserError[0].textContent); const to = xmlDoc.getElementsByTagName("to")[0]?.childNodes[0]?.nodeValue; const body = xmlDoc.getElementsByTagName("body")[0]?.childNodes[0]?.nodeValue; Terminal.print(`XML Parsed: To='${to}', Body='${body}'`, false, 'success'); } catch (e) { Terminal.print(`XML Parsing Error: ${e.message}`, false, 'error'); } } },
            pyScriptRunner: { /* ... as in v0.5 ... */ codeArea: null, outputArea: null, init: () => { const content = document.createElement('div'); const title = document.createElement('h3'); title.textContent = 'PyScript Runner'; title.className = 'text-lg font-semibold mb-2 text-gray-800'; AppManager.apps.pyScriptRunner.codeArea = document.createElement('textarea'); AppManager.apps.pyScriptRunner.codeArea.id = 'pyscript-code-area'; AppManager.apps.pyScriptRunner.codeArea.placeholder = '# Enter Python code here\nprint("Hello from PyScript in OBPI!")'; AppManager.apps.pyScriptRunner.codeArea.value = 'import datetime\n\nprint(f"Hello from PyScript! The current time is {datetime.datetime.now()}")'; const runButton = document.createElement('button'); runButton.textContent = 'Run Python Code'; runButton.className = 'px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 self-start my-2'; runButton.onclick = () => AppManager.apps.pyScriptRunner.runCode(); AppManager.apps.pyScriptRunner.outputArea = document.createElement('div'); AppManager.apps.pyScriptRunner.outputArea.id = 'pyscript-output-area'; AppManager.apps.pyScriptRunner.outputArea.textContent = 'PyScript output will appear here (and in browser console)...'; content.appendChild(title); content.appendChild(AppManager.apps.pyScriptRunner.codeArea); content.appendChild(runButton); content.appendChild(AppManager.apps.pyScriptRunner.outputArea); return content; }, runCode: (codeToRun) => { const code = codeToRun || AppManager.apps.pyScriptRunner.codeArea.value; if (!code) { if(AppManager.apps.pyScriptRunner.outputArea) AppManager.apps.pyScriptRunner.outputArea.textContent = 'No Python code to run.'; return; } if(AppManager.apps.pyScriptRunner.outputArea) AppManager.apps.pyScriptRunner.outputArea.textContent = 'Executing Python via PyScript...\n(Check browser console for PyScript logs & detailed output)\n'; const oldPyScriptElement = document.getElementById('dynamic-pyscript-tag'); if (oldPyScriptElement) oldPyScriptElement.remove(); const pyScriptElement = document.createElement('py-script'); pyScriptElement.id = 'dynamic-pyscript-tag'; const augmentedCode = ` import sys\nimport io\nfrom js import AppManager\nclass JsStdout(io.StringIO):\n    def write(self, s):\n        super().write(s)\n        AppManager.apps.pyScriptRunner.logOutput(s, isError=False)\nclass JsStderr(io.StringIO):\n    def write(self, s):\n        super().write(s)\n        AppManager.apps.pyScriptRunner.logOutput(s, isError=True)\nsys.stdout = JsStdout()\nsys.stderr = JsStderr()\ntry:\n    ${code}\nexcept Exception as e:\n    print(f"Python Error: {e}") `; pyScriptElement.textContent = augmentedCode; document.body.appendChild(pyScriptElement); OBPI.kernel.log("Dynamic PyScript element added for execution.", "info"); }, logOutput: (message, isError = false) => { if (AppManager.apps.pyScriptRunner.outputArea) { const entry = document.createElement('div'); entry.textContent = message; if(isError) entry.style.color = 'red'; AppManager.apps.pyScriptRunner.outputArea.appendChild(entry); AppManager.apps.pyScriptRunner.outputArea.scrollTop = AppManager.apps.pyScriptRunner.outputArea.scrollHeight; } if(Terminal && Terminal.print) Terminal.print(`PyScript> ${message.trim()}`, false, isError ? 'error' : 'info'); } },
            pyIDE: { /* ... as in v0.5 ... */ currentFilePath: null, codeAreaElement:null, outputAreaElement:null, currentFileDisplay:null, init: () => { const content = document.createElement('div'); content.className = 'p-1 h-full flex flex-col'; const menuBar = document.createElement('div'); menuBar.className = 'flex gap-2 mb-2 p-1 border-b'; menuBar.innerHTML = ` <button class="save-btn px-2 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600">Save</button> <button class="open-btn px-2 py-1 text-xs bg-gray-500 text-white rounded hover:bg-gray-600">Open</button> <span class="current-file-display text-xs italic self-center ml-auto">No file open</span> `; const codeArea = document.createElement('textarea'); codeArea.id = 'pyide-code-area'; codeArea.value = '# Python IDE - New File\nprint("Hello from OBPI PyIDE")'; const outputArea = document.createElement('div'); outputArea.id = 'pyide-output-area'; outputArea.textContent = 'Python output...'; const runBtn = document.createElement('button'); runBtn.textContent = 'Run in PyIDE'; runBtn.className = 'px-3 py-1.5 bg-green-600 text-white rounded hover:bg-green-700 self-start mt-2 text-sm'; content.appendChild(menuBar); content.appendChild(codeArea); content.appendChild(outputArea); content.appendChild(runBtn); AppManager.apps.pyIDE.codeAreaElement = codeArea; AppManager.apps.pyIDE.outputAreaElement = outputArea; AppManager.apps.pyIDE.currentFileDisplay = menuBar.querySelector('.current-file-display'); menuBar.querySelector('.save-btn').onclick = AppManager.apps.pyIDE.saveFile; menuBar.querySelector('.open-btn').onclick = AppManager.apps.pyIDE.openFile; runBtn.onclick = () => AppManager.apps.pyIDE.runCurrentCode(); return content; }, updateFileDisplay: () => { if (AppManager.apps.pyIDE.currentFileDisplay) AppManager.apps.pyIDE.currentFileDisplay.textContent = AppManager.apps.pyIDE.currentFilePath || 'Unsaved File'; }, saveFile: () => { const currentCode = AppManager.apps.pyIDE.codeAreaElement.value; const defaultName = AppManager.apps.pyIDE.currentFilePath ? AppManager.apps.pyIDE.currentFilePath.split('/').pop() : 'new_script.py'; Modal.prompt('Save Python Script', 'Enter filename (e.g., script.py):', defaultName, (filename) => { if (filename) { const savePath = filename.startsWith('/') ? filename : OBPI.currentPath + filename; AppManager.cliCommands.write([savePath.split('/').pop(), `"${currentCode.replace(/"/g, '\\"')}"`]); AppManager.apps.pyIDE.currentFilePath = savePath; AppManager.apps.pyIDE.updateFileDisplay(); Terminal.print(`PyIDE: Saved to ${savePath}`, false, 'success'); } }); }, openFile: () => { Modal.prompt('Open Python Script', 'Enter path to file (e.g., /home/guest/python_scripts/hello.py):', OBPI.currentPath, (filePath) => { if (filePath) { const {node, error} = FileSystem.resolvePath(filePath); if (node && node.type === 'file') { AppManager.apps.pyIDE.codeAreaElement.value = node.content; AppManager.apps.pyIDE.currentFilePath = filePath; AppManager.apps.pyIDE.updateFileDisplay(); AppManager.apps.pyIDE.outputAreaElement.textContent = `Opened ${filePath}`; } else { Modal.show('Error', `Could not open file: ${error || 'Not a file or does not exist'}`); AppManager.apps.pyIDE.outputAreaElement.textContent = `Error opening ${filePath}: ${error || 'Not a file'}`; } } }); }, runCurrentCode: () => { const code = AppManager.apps.pyIDE.codeAreaElement.value; if (AppManager.apps.pyIDE.outputAreaElement) AppManager.apps.pyIDE.outputAreaElement.textContent = 'Executing Python...\n'; const oldPyScriptElement = document.getElementById('dynamic-pyide-script-tag'); if (oldPyScriptElement) oldPyScriptElement.remove(); const pyScriptElement = document.createElement('py-script'); pyScriptElement.id = 'dynamic-pyide-script-tag'; const augmentedCode = ` import sys\nimport io\nfrom js import AppManager\nclass IDEStdout(io.StringIO):\n    def write(self, s):\n        super().write(s)\n        AppManager.apps.pyIDE.logOutput(s, False)\nclass IDEStderr(io.StringIO):\n    def write(self, s):\n        super().write(s)\n        AppManager.apps.pyIDE.logOutput(s, True)\nsys.stdout = IDEStdout()\nsys.stderr = IDEStderr()\ntry:\n    ${code}\nexcept Exception as e:\n    print(f"Python Error: {e}") `; pyScriptElement.textContent = augmentedCode; document.body.appendChild(pyScriptElement); }, logOutput: (message, isError = false) => { if (AppManager.apps.pyIDE.outputAreaElement) { const entry = document.createElement('span'); entry.textContent = message; if(isError) entry.style.color = '#ff6b6b'; else entry.style.color = '#90ee90'; AppManager.apps.pyIDE.outputAreaElement.appendChild(entry); AppManager.apps.pyIDE.outputAreaElement.scrollTop = AppManager.apps.pyIDE.outputAreaElement.scrollHeight; } } },
            networkManager: { /* ... as in v0.5 ... */ simulatedNetworks: [ { ssid: "OBPI_WiFi_Guest", signal: 85, security: "WPA2" }, { ssid: "CoffeeShop_Free", signal: 60, security: "Open" }, { ssid: "MyHomeNet_5G", signal: 95, security: "WPA3" }, ], init: () => { const content = document.createElement('div'); content.innerHTML = `<h3 class="text-lg font-semibold mb-3">Network Manager (Simulated)</h3> <button class="scan-btn px-3 py-1.5 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm mb-3">Scan for Networks</button> <ul class="network-list"></ul>`; content.querySelector('.scan-btn').onclick = async () => { const hasPerm = await OBPI.kernel.requestPermission('network_scan', 'NetworkManagerApp'); if(hasPerm) AppManager.apps.networkManager.renderNetworks(content); else Modal.show("Permission Denied", "Network scan permission was not granted."); }; return content; }, getSimulatedNetworks: () => AppManager.apps.networkManager.simulatedNetworks, renderNetworks: (container) => { const list = container.querySelector('.network-list'); list.innerHTML = 'Scanning...'; setTimeout(() => { list.innerHTML = ''; AppManager.apps.networkManager.simulatedNetworks.forEach(net => { const item = document.createElement('li'); item.innerHTML = `<span>${net.ssid} (Signal: ${net.signal}%, Security: ${net.security})</span> <button data-ssid="${net.ssid}" class="connect-btn px-2 py-0.5 bg-green-500 text-white text-xs rounded hover:bg-green-600">Connect</button>`; item.querySelector('.connect-btn').onclick = async (e) => { const ssid = e.target.dataset.ssid; const hasPerm = await OBPI.kernel.requestPermission('network_connect', 'NetworkManagerApp'); if(hasPerm) AppManager.cliCommands.net(['connect', ssid]); else Modal.show("Permission Denied", "Network connect permission was not granted."); }; list.appendChild(item); }); }, 1000); } },
            bluetoothManager: { /* ... as in v0.5 ... */ simulatedDevices: [ { name: "MyPhone_BT", type: "Phone" }, { name: "WirelessHeadphones", type: "Audio" }, { name: "SmartWatchX", type: "Watch" } ], init: () => { const content = document.createElement('div'); content.innerHTML = `<h3 class="text-lg font-semibold mb-3">Bluetooth Manager (Simulated)</h3> <button class="scan-btn px-3 py-1.5 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm mb-3">Scan for Devices</button> <ul class="device-list"></ul>`; content.querySelector('.scan-btn').onclick = async () => { const hasPerm = await OBPI.kernel.requestPermission('bluetooth_scan', 'BluetoothManagerApp'); if(hasPerm) AppManager.apps.bluetoothManager.renderDevices(content); else Modal.show("Permission Denied", "Bluetooth scan permission was not granted."); }; return content; }, getSimulatedDevices: () => AppManager.apps.bluetoothManager.simulatedDevices, renderDevices: (container) => { const list = container.querySelector('.device-list'); list.innerHTML = 'Scanning...';  setTimeout(() => { list.innerHTML = ''; AppManager.apps.bluetoothManager.simulatedDevices.forEach(dev => { const item = document.createElement('li'); item.innerHTML = `<span>${dev.name} (Type: ${dev.type})</span> <button data-devname="${dev.name}" class="pair-btn px-2 py-0.5 bg-green-500 text-white text-xs rounded hover:bg-green-600">Pair</button>`; item.querySelector('.pair-btn').onclick = async (e) => { const devName = e.target.dataset.devname; const hasPerm = await OBPI.kernel.requestPermission('bluetooth_pair', 'BluetoothManagerApp'); if(hasPerm) AppManager.cliCommands.bt(['pair', devName]); else Modal.show("Permission Denied", "Bluetooth pair permission was not granted."); }; list.appendChild(item); }); }, 1000); } },
            themeSettings: { /* ... as in v0.5 ... */ launch: () => { const content = document.createElement('div'); content.innerHTML = ` <h3 class="text-lg font-semibold mb-3">Theme Settings</h3> <p class="mb-2 text-sm">Select a theme for the OBPI interface.</p> <div class="flex gap-4"> <button data-theme="dark" class="theme-btn px-4 py-2 bg-gray-700 text-white rounded hover:bg-gray-600">Dark Theme</button> <button data-theme="light" class="theme-btn px-4 py-2 bg-gray-200 text-black rounded hover:bg-gray-300">Light Theme</button> </div> `; content.querySelectorAll('.theme-btn').forEach(btn => { btn.onclick = () => AppManager.apps.themeSettings.setTheme(btn.dataset.theme); }); WindowManager.create('theme-settings', 'Theme Settings', content, {width: '400px', height:'250px'}); }, setTheme: (themeName) => { document.body.classList.remove('light-theme', 'dark-theme'); if (themeName === 'light') { document.body.classList.add('light-theme'); OBPI.activeTheme = 'light'; } else { OBPI.activeTheme = 'dark'; } localStorage.setItem(OBPI.config.themeStorageKey, OBPI.activeTheme); OBPI.kernel.log(`Theme changed to ${OBPI.activeTheme}`); if (Terminal.promptElement) Terminal.updatePrompt(); DesktopIcons.render(); }, loadTheme: () => { const savedTheme = localStorage.getItem(OBPI.config.themeStorageKey); if (savedTheme) AppManager.apps.themeSettings.setTheme(savedTheme); else AppManager.apps.themeSettings.setTheme('dark'); } },
            pepxExplorer: { // New PEPx Explorer App
                fileManager: null,
                init: () => {
                    const content = document.createElement('div'); // This div will be the container for PEPx UI
                    content.style.width = '100%';
                    content.style.height = '100%';
                    content.style.overflow = 'hidden'; // PEPxFileManager will manage its own scrolling

                    if (!OBPI.pepxInstance) {
                        OBPI.pepxInstance = new PEPxStorage(); // Use default dimensions
                         // Initialize canvases asynchronously, PEPxFileManager will handle UI updates when ready
                        OBPI.pepxInstance.initializeCanvases().then(() => {
                            if (AppManager.apps.pepxExplorer.fileManager) {
                                AppManager.apps.pepxExplorer.fileManager.refreshFileList();
                            }
                        }).catch(err => OBPI.kernel.log("Error initializing PEPx canvases for explorer: " + err, "error"));
                    }
                    
                    AppManager.apps.pepxExplorer.fileManager = new PEPxFileManager(OBPI.pepxInstance);
                    // initUI now takes the DOM element directly
                    AppManager.apps.pepxExplorer.fileManager.initUI(content); 
                    
                    // Load some mock files into PEPx for demo if its metadata is empty
                    if (Object.keys(OBPI.pepxInstance.metadataStore.files).length === 0) {
                        const mockPepxFiles = [
                            { id: OBPI.pepxInstance.generateUniqueId(), name: 'PixelDocs', path: '/', parentPath: null, type: 'folder', size: 0, created: new Date().toISOString(), modified: new Date().toISOString() },
                            { id: OBPI.pepxInstance.generateUniqueId(), name: 'EncodedImage.pepximg', path: '/', parentPath: null, type: 'image/pepx', size: 1024 * 500, storedByteLength: 1024*500, created: new Date().toISOString(), modified: new Date().toISOString() }
                        ];
                        mockPepxFiles.forEach(f => OBPI.pepxInstance.metadataStore.addFile(f));
                        AppManager.apps.pepxExplorer.fileManager.refreshFileList();
                    }

                    return content; // Return the container div
                }
            }
        }
    };

    // --- DecHex Language Interpreter ---
    const DecHexLang = { /* ... as in v0.5 ... */ 
        memory: new Uint8Array(256), stack: [],
        interpret: (hexString) => { let acc = 0, pc = 0, flags = { zero: false }; let output = ""; DecHexLang.stack = []; DecHexLang.memory.fill(0); const code = hexString.replace(/\s/g, '').match(/.{1,2}/g)?.map(byte => parseInt(byte, 16)) || []; if (hexString.replace(/\s/g, '').length % 2 !== 0) throw new Error("Invalid hex string length."); while (pc < code.length) { const op = code[pc++]; switch (op) { case 0x0A: acc += code[pc++]; break; case 0x0B: acc -= code[pc++]; break; case 0x0C: output += `ACC: ${acc} (0x${acc.toString(16).padStart(2,'0')})\n`; break; case 0x0D: acc = code[pc++]; break; case 0x0E: DecHexLang.stack.push(acc); break; case 0x0F: if(DecHexLang.stack.length === 0) throw new Error("Stack underflow"); acc = DecHexLang.stack.pop(); break; case 0x10: if(DecHexLang.stack.length === 0) throw new Error("Stack empty for peek"); output += `STACK_PEEK: ${DecHexLang.stack[DecHexLang.stack.length-1]}\n`; break; case 0x11: const jmpAddr = code[pc++]; if (acc === 0) pc = jmpAddr; flags.zero = (acc === 0); break; case 0x12: const memAddrStore = code[pc++]; if(memAddrStore >= DecHexLang.memory.length) throw new Error(`Memory out of bounds: ${memAddrStore}`); DecHexLang.memory[memAddrStore] = acc & 0xFF; output += `Stored ${acc & 0xFF} to MEM[${memAddrStore}]\n`; break; case 0x13: const memAddrLoad = code[pc++]; if(memAddrLoad >= DecHexLang.memory.length) throw new Error(`Memory out of bounds: ${memAddrLoad}`); acc = DecHexLang.memory[memAddrLoad]; output += `Loaded ${acc} from MEM[${memAddrLoad}] to ACC\n`; break; case undefined: throw new Error("Unexpected end of code (operand missing)."); default: throw new Error(`Unknown OpCode: 0x${op.toString(16).padStart(2,'0')} at PC=${pc-1}`); } if (acc > 255) acc = 255; if (acc < 0) acc = 0; } return output.trim() || `Execution complete. Final ACC: ${acc}`; }
    };
    
    // --- Desktop Icons Module ---
    const DesktopIcons = { /* ... as in v0.5 ... */ 
        icons: [], 
        load: () => { const storedIcons = localStorage.getItem(OBPI.config.desktopIconStorageKey); if (storedIcons) { try { DesktopIcons.icons = JSON.parse(storedIcons); } catch (e) { OBPI.kernel.log("Error parsing desktop icons from localStorage", "error"); DesktopIcons.setDefaultIcons(); } } else { DesktopIcons.setDefaultIcons(); } DesktopIcons.render(); },
        save: () => { try { localStorage.setItem(OBPI.config.desktopIconStorageKey, JSON.stringify(DesktopIcons.icons)); } catch (e) { OBPI.kernel.log("Error saving desktop icons to localStorage", "error"); } },
        setDefaultIcons: () => { DesktopIcons.icons = [ { id: 'icon-terminal', name: 'Terminal', icon: 'ðŸ–¥ï¸', action: 'terminal', type: 'app' }, { id: 'icon-webview', name: 'Web View', icon: 'ðŸŒ', action: 'web_view', type: 'app' }, { id: 'icon-pyide', name: 'Python IDE', icon: 'ðŸ', action: 'py_ide', type: 'app' }, { id: 'icon-pepx', name: 'PEPx Explorer', icon: 'ðŸ–¼ï¸', action: 'pepx_explorer', type: 'app' }, { id: 'icon-readme', name: 'README.txt', icon: 'ðŸ“„', action: '/home/guest/readme.txt', type: 'file' } ]; DesktopIcons.save(); },
        add: (name, iconChar, action, type = 'app') => { const id = `icon-${name.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`; DesktopIcons.icons.push({ id, name, icon: iconChar, action, type }); DesktopIcons.save(); DesktopIcons.render(); },
        remove: (id) => { DesktopIcons.icons = DesktopIcons.icaons.filter(icon => icon.id !== id); DesktopIcons.save(); DesktopIcons.render(); },
        render: () => { Array.from(OBPI.desktopElement.children).forEach(child => { if (child.id !== 'webgl-canvas' && child.id !== 'fullscreen-lock-overlay') child.remove(); }); DesktopIcons.icons.forEach(iconData => { const iconEl = document.createElement('div'); iconEl.className = 'desktop-icon'; iconEl.title = iconData.name; iconEl.dataset.id = iconData.id; iconEl.dataset.action = iconData.action; iconEl.dataset.type = iconData.type; if (iconData.icon.startsWith('<svg') || iconData.icon.includes('/')) iconEl.innerHTML = `<img src="${iconData.icon}" alt="${iconData.name}"><span>${iconData.name}</span>`; else iconEl.innerHTML = `<div class="icon-placeholder">${iconData.icon}</div><span>${iconData.name}</span>`; iconEl.ondblclick = () => { if (iconData.type === 'app') AppManager.cliCommands.run([iconData.action]); else if (iconData.type === 'file') AppManager.cliCommands.exec([iconData.action]); }; iconEl.draggable = true; iconEl.ondragstart = (e) => { e.dataTransfer.setData('text/plain', iconData.id); }; OBPI.desktopElement.appendChild(iconEl); }); }
    };
    OBPI.desktopElement.ondragover = (e) => e.preventDefault();
    OBPI.desktopElement.ondrop = (e) => { e.preventDefault(); };


    // --- Context Menu Setup ---
    function setupContextMenu() { /* ... as in v0.5 ... */ 
        const items = [ { label: 'Create Folder...', action: 'create-folder', icon: 'ðŸ“' }, { label: 'Create Shortcut...', action: 'create-shortcut', icon: 'ðŸ”—' }, { label: 'Terminal Settings', action: 'term-settings', icon: 'âš™ï¸' }, { label: 'Change Background...', action: 'change-bg', icon: 'ðŸ–¼ï¸' }, {label: 'Toggle Theme', action: 'toggle-theme', icon: 'ðŸŽ¨'}, { label: 'System Info', action: 'sys-info', icon: 'â„¹ï¸' } ]; OBPI.contextMenuElement.innerHTML = ''; items.forEach(item => { const menuItem = document.createElement('div'); menuItem.className = 'context-menu-item'; menuItem.innerHTML = `<span class="mr-2">${item.icon}</span> ${item.label}`; menuItem.onclick = () => { OBPI.contextMenuElement.classList.add('hidden'); handleContextMenuAction(item.action); }; OBPI.contextMenuElement.appendChild(menuItem); }); OBPI.desktopElement.oncontextmenu = (e) => { e.preventDefault(); OBPI.contextMenuElement.style.top = `${e.clientY}px`; OBPI.contextMenuElement.style.left = `${e.clientX}px`; OBPI.contextMenuElement.classList.remove('hidden'); }; document.onclick = (e) => { if (!OBPI.contextMenuElement.contains(e.target) && !e.target.closest('#start-menu-button') && !e.target.closest('#start-menu')) OBPI.contextMenuElement.classList.add('hidden'); };
    }
    function handleContextMenuAction(action) { /* ... as in v0.5 ... */ 
        switch(action) { case 'create-folder': Modal.prompt('Create Folder', 'Enter folder name:', 'NewFolder', (name) => { if (name) AppManager.cliCommands.mkdir([name]); }); break;  case 'create-shortcut':  Modal.prompt('Create Shortcut', 'Enter App ID or File Path for shortcut:', 'web_view', (target) => { if (target) { const name = prompt("Enter shortcut name:", target.split('/').pop() || target); if (name) { const type = AppManager.installedApps[target] ? 'app' : 'file'; const icon = AppManager.installedApps[target]?.icon || (type === 'file' ? 'ðŸ“„' : 'ðŸš€'); DesktopIcons.add(name, icon, target, type); } } }); break; case 'term-settings': Modal.show('Terminal Settings', 'Terminal settings are conceptual for now.'); break;  case 'change-bg': Modal.show('Change Background', 'Background customization is planned for a future version.'); break;  case 'toggle-theme': AppManager.apps.themeSettings.setTheme(OBPI.activeTheme === 'dark' ? 'light' : 'dark'); break; case 'sys-info': const sysInfoContent = `<strong>OBPI Version:</strong> ${OBPI.version}<br><strong>User Agent:</strong> ${navigator.userAgent.substring(0,60)}...<br><strong>Screen Resolution:</strong> ${window.screen.width}x${window.screen.height}<br><strong>Simulated File System:</strong> ${FileSystem.FS_STORAGE_KEY} (localStorage)<br><strong>Current Theme:</strong> ${OBPI.activeTheme}`; Modal.show('System Information', sysInfoContent); break;  default: OBPI.kernel.log(`Unknown context menu action: ${action}`, 'warn');  }
    }
    
    // --- Start Menu ---
    function setupStartMenu() { /* ... as in v0.5 ... */ 
        OBPI.startMenuButton.onclick = (e) => { e.stopPropagation(); OBPI.startMenuElement.classList.toggle('hidden'); }; document.addEventListener('click', (e) => { if (!OBPI.startMenuElement.contains(e.target) && e.target !== OBPI.startMenuButton) OBPI.startMenuElement.classList.add('hidden'); }); renderStartMenuItems();
    }
    function renderStartMenuItems() { /* ... as in v0.5 ... */ 
        OBPI.startMenuElement.innerHTML = ''; Object.entries(AppManager.installedApps).forEach(([id, app]) => { const item = document.createElement('a'); item.href = '#'; item.className = 'start-menu-item'; item.innerHTML = `<span class="mr-2">${app.icon || 'ðŸ”¹'}</span>${app.name}`; item.onclick = (e) => { e.preventDefault(); app.launch(); OBPI.startMenuElement.classList.add('hidden'); }; OBPI.startMenuElement.appendChild(item); }); const settingsItem = document.createElement('a'); settingsItem.href = '#'; settingsItem.className = 'start-menu-item mt-2 border-t border-gray-700 pt-2'; settingsItem.innerHTML = `<span class="mr-2">âš™ï¸</span>Theme Settings`; settingsItem.onclick = (e) => { e.preventDefault(); AppManager.installedApps['theme_settings'].launch(); OBPI.startMenuElement.classList.add('hidden'); }; OBPI.startMenuElement.appendChild(settingsItem);
    }

    // --- Initialization Function ---
    function main() {
        OBPI.kernel.log(`Initializing ${OBPI.name} v${OBPI.version}...`);
        AppManager.apps.themeSettings.loadTheme(); 
        initWebGLBackground();
        FileSystem.init();
        OBPI.envVars['HOME'] = '/home/guest/'; 
        OBPI.envVars['USER'] = 'guest';
        OBPI.envVars['PATH'] = '/bin:/home/guest/bin'; 
        WindowManager.restoreAllWindowStates(); 
        Terminal.init(); 
        setupContextMenu();
        setupStartMenu();
        DesktopIcons.load();

        if (!OBPI.windows['welcome-note']) {
            WindowManager.create('welcome-note', `Welcome to ${OBPI.name}!`, 
                `<div class="p-3"> <h2 class="text-xl font-semibold mb-2">${OBPI.name} v${OBPI.version}</h2> <p class="text-sm mb-1">Now featuring PEPx Pixel Storage Explorer and enhanced CLI capabilities.</p> <p class="text-sm mb-1">Explore the PyIDE, simulated devices, desktop icons, and theming.</p> <p class="text-sm">Right-click desktop for options. Click OBPI button for Start Menu. Type 'help' in terminal.</p> <p class="text-xs mt-3 text-gray-500">Timestamp: ${new Date().toISOString()}</p> </div>`, 
                { width: '600px', height: '380px', top: '50px', left: '50px' }
            );
        }
        if (!OBPI.windows['terminal']) { if (OBPI.windows['terminal']) WindowManager.focus('terminal'); }

        document.addEventListener('fullscreenchange', () => { if (!document.fullscreenElement) { OBPI.isLocked = false; OBPI.fullscreenLockOverlay.style.display = 'none'; OBPI.kernel.log("Exited fullscreen mode.", "info"); } else { OBPI.isLocked = true; OBPI.fullscreenLockOverlay.style.display = 'block'; OBPI.kernel.log("Entered fullscreen mode.", "info"); } });
        document.addEventListener('webkitfullscreenchange', () => { if (!document.webkitFullscreenElement) { OBPI.isLocked = false; OBPI.fullscreenLockOverlay.style.display = 'none'; } else { OBPI.isLocked = true; OBPI.fullscreenLockOverlay.style.display = 'block'; } });

        // Initialize PEPx storage globally but lazily for canvases
        OBPI.pepxInstance = new PEPxStorage(); // Canvases init on first use
        OBPI.kernel.log(`PEPx Storage system instantiated. Canvases will init on first use.`, 'info');

        OBPI.kernel.log(`${OBPI.name} fully initialized and ready.`, "success");
    }

    function ensureHttps(url) { if (!/^https?:\/\//i.test(url)) return 'https://' + url; return url; }

    document.addEventListener('DOMContentLoaded', main);

    </script>
</body>
</html>
